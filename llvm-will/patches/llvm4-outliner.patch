From 8eb5d4addcbfb208fea8f5a8b620c0cf4e8a330b Mon Sep 17 00:00:00 2001
From: river_riddle <river.riddle@digipen.edu>
Date: Wed, 19 Jul 2017 22:28:27 -0700
Subject: [PATCH] Squash code outliner commits (River707/llvm)

56237f56e85447f28184756161b58a4c2af98052
->
56768eb3fe49b03231b430223ce70b25ca836689
---
 include/llvm/InitializePasses.h                 |    1 +
 include/llvm/Transforms/IPO.h                   |    6 +
 include/llvm/Transforms/IPO/CodeSizeOutliner.h  |   35 +
 include/llvm/Transforms/Scalar/GVNExpression.h  |   59 +-
 lib/Passes/PassBuilder.cpp                      |   17 +
 lib/Passes/PassRegistry.def                     |    1 +
 lib/Transforms/IPO/CMakeLists.txt               |    1 +
 lib/Transforms/IPO/CodeSizeOutliner.cpp         | 2105 +++++++++++++++++++++++
 lib/Transforms/IPO/IPO.cpp                      |    1 +
 lib/Transforms/IPO/PassManagerBuilder.cpp       |   11 +
 test/Transforms/CodeSizeOutliner/attributes.ll  |   46 +
 test/Transforms/CodeSizeOutliner/basic.ll       |   22 +
 test/Transforms/CodeSizeOutliner/multioutput.ll |   41 +
 test/Transforms/CodeSizeOutliner/output.ll      |   27 +
 14 files changed, 2370 insertions(+), 3 deletions(-)
 create mode 100644 include/llvm/Transforms/IPO/CodeSizeOutliner.h
 create mode 100644 lib/Transforms/IPO/CodeSizeOutliner.cpp
 create mode 100644 test/Transforms/CodeSizeOutliner/attributes.ll
 create mode 100644 test/Transforms/CodeSizeOutliner/basic.ll
 create mode 100644 test/Transforms/CodeSizeOutliner/multioutput.ll
 create mode 100644 test/Transforms/CodeSizeOutliner/output.ll

diff --git a/include/llvm/InitializePasses.h b/include/llvm/InitializePasses.h
index a34ebaf18a0..0655f566c64 100644
--- a/include/llvm/InitializePasses.h
+++ b/include/llvm/InitializePasses.h
@@ -94,6 +94,7 @@ void initializeCallGraphViewerPass(PassRegistry&);
 void initializeCallGraphWrapperPassPass(PassRegistry &);
 void initializeCodeGenPreparePass(PassRegistry&);
 void initializeCountingFunctionInserterPass(PassRegistry&);
+void initializeCodeSizeOutlinerLegacyPassPass(PassRegistry&);
 void initializeConstantHoistingLegacyPassPass(PassRegistry&);
 void initializeConstantMergeLegacyPassPass(PassRegistry &);
 void initializeConstantPropagationPass(PassRegistry&);
diff --git a/include/llvm/Transforms/IPO.h b/include/llvm/Transforms/IPO.h
index dd55062e56f..c54ba735be8 100644
--- a/include/llvm/Transforms/IPO.h
+++ b/include/llvm/Transforms/IPO.h
@@ -206,6 +206,12 @@ ModulePass *createMergeFunctionsPass();
 ModulePass *createPartialInliningPass();
 
 //===----------------------------------------------------------------------===//
+/// createCodeSizeOutlinerPass - This pass outlines congruent parts of
+/// functions.
+///
+ModulePass *createCodeSizeOutlinerPass(unsigned SizeLevel);
+
+//===----------------------------------------------------------------------===//
 // createMetaRenamerPass - Rename everything with metasyntatic names.
 //
 ModulePass *createMetaRenamerPass();
diff --git a/include/llvm/Transforms/IPO/CodeSizeOutliner.h b/include/llvm/Transforms/IPO/CodeSizeOutliner.h
new file mode 100644
index 00000000000..a0cdf057823
--- /dev/null
+++ b/include/llvm/Transforms/IPO/CodeSizeOutliner.h
@@ -0,0 +1,35 @@
+//===-- CodeSizeOutliner.h - DCE unreachable internal functions ------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This transform outlines congruent chains of instructions from the current
+//   module.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TRANSFORMS_IPO_CODESIZEOUTLINER_H
+#define LLVM_TRANSFORMS_IPO_CODESIZEOUTLINER_H
+
+#include "llvm/IR/Module.h"
+#include "llvm/IR/PassManager.h"
+
+namespace llvm {
+
+/// Pass to remove unused function declarations.
+class CodeSizeOutlinerPass : public PassInfoMixin<CodeSizeOutlinerPass> {
+public:
+  CodeSizeOutlinerPass(unsigned SizeLevel = 2) : SizeLevel(SizeLevel) {}
+  PreservedAnalyses run(Module &M, ModuleAnalysisManager &);
+
+private:
+  unsigned SizeLevel;
+};
+
+} // namespace llvm
+
+#endif // LLVM_TRANSFORMS_IPO_CODESIZEOUTLINER_H
diff --git a/include/llvm/Transforms/Scalar/GVNExpression.h b/include/llvm/Transforms/Scalar/GVNExpression.h
index 3458696e068..c47e682eaa9 100644
--- a/include/llvm/Transforms/Scalar/GVNExpression.h
+++ b/include/llvm/Transforms/Scalar/GVNExpression.h
@@ -37,6 +37,7 @@ enum ExpressionType {
   ET_Constant,
   ET_Variable,
   ET_Unknown,
+  ET_Relaxed,
   ET_BasicStart,
   ET_Basic,
   ET_Call,
@@ -599,7 +600,59 @@ public:
     OS << " inst = " << *Inst;
   }
 };
-}
-}
 
-#endif
+} // end namespace GVNExpression
+
+} // end namespace llvm
+
+struct HashedExpression;
+namespace llvm {
+  struct ExactEqualsExpression {
+    const GVNExpression::Expression &E;
+    explicit ExactEqualsExpression(const GVNExpression::Expression &E) : E(E) {}
+    hash_code getComputedHash() const { return E.getComputedHash(); }
+    bool operator==(const GVNExpression::Expression &Other) const {
+      return E.exactlyEquals(Other);
+    }
+  };
+
+  template <> struct DenseMapInfo<const GVNExpression::Expression *> {
+    static const GVNExpression::Expression *getEmptyKey() {
+      auto Val = static_cast<uintptr_t>(-1);
+      Val <<= PointerLikeTypeTraits<const GVNExpression::Expression *>::NumLowBitsAvailable;
+      return reinterpret_cast<const GVNExpression::Expression *>(Val);
+    }
+    static const GVNExpression::Expression *getTombstoneKey() {
+      auto Val = static_cast<uintptr_t>(~1U);
+      Val <<= PointerLikeTypeTraits<const GVNExpression::Expression *>::NumLowBitsAvailable;
+      return reinterpret_cast<const GVNExpression::Expression *>(Val);
+    }
+    static unsigned getHashValue(const GVNExpression::Expression *E) {
+      return E->getComputedHash();
+    }
+    static unsigned getHashValue(const ExactEqualsExpression &E) {
+      return E.getComputedHash();
+    }
+    static bool isEqual(const ExactEqualsExpression &LHS, const GVNExpression::Expression *RHS) {
+      if (RHS == getTombstoneKey() || RHS == getEmptyKey())
+        return false;
+      return LHS == *RHS;
+    }
+
+    static bool isEqual(const GVNExpression::Expression *LHS, const GVNExpression::Expression *RHS) {
+      if (LHS == RHS)
+        return true;
+      if (LHS == getTombstoneKey() || RHS == getTombstoneKey() ||
+      LHS == getEmptyKey() || RHS == getEmptyKey())
+        return false;
+      // Compare hashes before equality.  This is *not* what the hashtable does,
+      // since it is computing it modulo the number of buckets, whereas we are
+      // using the full hash keyspace.  Since the hashes are precomputed, this
+      // check is *much* faster than equality.
+      if (LHS->getComputedHash() != RHS->getComputedHash())
+        return false;
+      return *LHS == *RHS;
+    }
+  };
+} // end namespace llvm
+#endif // LLVM_TRANSFORMS_SCALAR_GVNEXPRESSION_H
diff --git a/lib/Passes/PassBuilder.cpp b/lib/Passes/PassBuilder.cpp
index 2994a07b1cc..c420bca3423 100644
--- a/lib/Passes/PassBuilder.cpp
+++ b/lib/Passes/PassBuilder.cpp
@@ -61,6 +61,8 @@
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Transforms/GCOVProfiler.h"
 #include "llvm/Transforms/IPO/AlwaysInliner.h"
+#include "llvm/Transforms/IPO/ArgumentPromotion.h"
+#include "llvm/Transforms/IPO/CodeSizeOutliner.h"
 #include "llvm/Transforms/IPO/ConstantMerge.h"
 #include "llvm/Transforms/IPO/CrossDSOCFI.h"
 #include "llvm/Transforms/IPO/DeadArgumentElimination.h"
@@ -144,6 +146,11 @@ using namespace llvm;
 
 static Regex DefaultAliasRegex("^(default|lto-pre-link|lto)<(O[0123sz])>$");
 
+static cl::opt<bool> EnableEarlyCSO(
+    "enable-npm-early-cso", cl::init(false), cl::Hidden,
+    cl::desc("Enable an early run of the code size outlining pass for the new PM (default = off)"));
+
+
 static bool isOptimizingForSize(PassBuilder::OptimizationLevel Level) {
   switch (Level) {
   case PassBuilder::O0:
@@ -434,6 +441,12 @@ PassBuilder::buildPerModuleDefaultPipeline(OptimizationLevel Level,
   MPM.addPass(RequireAnalysisPass<GlobalsAA>());
 #endif
 
+#if 0
+  // Add an early code size outlining pass.
+  if(EnableEarlyCSO && isOptimizingForSize(Level))
+    MPM.addPass(CodeSizeOutlinerPass(Level == Os ? 1 : 2));
+#endif
+
   // Now begin the main postorder CGSCC pipeline.
   // FIXME: The current CGSCC pipeline has its origins in the legacy pass
   // manager and trying to emulate its precise behavior. Much of this doesn't
@@ -527,6 +540,10 @@ PassBuilder::buildPerModuleDefaultPipeline(OptimizationLevel Level,
   // ADd the core optimizing pipeline.
   MPM.addPass(createModuleToFunctionPassAdaptor(std::move(OptimizePM)));
 
+  // Add the late outlining pass.
+  if(isOptimizingForSize(Level))
+    MPM.addPass(CodeSizeOutlinerPass(Level == Os ? 1 : 2));
+
   // Now we need to do some global optimization transforms.
   // FIXME: It would seem like these should come first in the optimization
   // pipeline and maybe be the bottom of the canonicalization pipeline? Weird
diff --git a/lib/Passes/PassRegistry.def b/lib/Passes/PassRegistry.def
index a9939fddb98..09a0ce5f5ea 100644
--- a/lib/Passes/PassRegistry.def
+++ b/lib/Passes/PassRegistry.def
@@ -39,6 +39,7 @@ MODULE_ALIAS_ANALYSIS("globals-aa", GlobalsAA())
 #define MODULE_PASS(NAME, CREATE_PASS)
 #endif
 MODULE_PASS("always-inline", AlwaysInlinerPass())
+MODULE_PASS("codesizeoutliner", CodeSizeOutlinerPass())
 MODULE_PASS("constmerge", ConstantMergePass())
 MODULE_PASS("cross-dso-cfi", CrossDSOCFIPass())
 MODULE_PASS("deadargelim", DeadArgumentEliminationPass())
diff --git a/lib/Transforms/IPO/CMakeLists.txt b/lib/Transforms/IPO/CMakeLists.txt
index 67f18a307b9..f551c1fe22c 100644
--- a/lib/Transforms/IPO/CMakeLists.txt
+++ b/lib/Transforms/IPO/CMakeLists.txt
@@ -2,6 +2,7 @@ add_llvm_library(LLVMipo
   AlwaysInliner.cpp
   ArgumentPromotion.cpp
   BarrierNoopPass.cpp
+  CodeSizeOutliner.cpp
   ConstantMerge.cpp
   CrossDSOCFI.cpp
   DeadArgumentElimination.cpp
diff --git a/lib/Transforms/IPO/CodeSizeOutliner.cpp b/lib/Transforms/IPO/CodeSizeOutliner.cpp
new file mode 100644
index 00000000000..dbff7a0dba5
--- /dev/null
+++ b/lib/Transforms/IPO/CodeSizeOutliner.cpp
@@ -0,0 +1,2105 @@
+//===-- CodeSizeOutliner.cpp - Propagate constants through calls -----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass implements a simple algorithm for outlining congruent chains of
+//  instructions from the current module.
+//
+//===----------------------------------------------------------------------===//
+#include "llvm/Transforms/IPO/CodeSizeOutliner.h"
+#include "llvm/ADT/BitVector.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/SparseBitVector.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Analysis/BranchProbabilityInfo.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/OptimizationDiagnosticInfo.h"
+#include "llvm/Analysis/ProfileSummaryInfo.h"
+#include "llvm/Analysis/TargetTransformInfo.h"
+#include "llvm/Bitcode/BitcodeWriterPass.h"
+#include "llvm/IR/CallSite.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/DIBuilder.h"
+#include "llvm/IR/DiagnosticInfo.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/Pass.h"
+#include "llvm/Transforms/IPO.h"
+#include "llvm/Transforms/Scalar/GVNExpression.h"
+#include <sstream>
+
+using namespace llvm;
+
+static cl::opt<unsigned> MinOccurrences(
+    "cso-min-occurrences", cl::init(2), cl::Hidden,
+    cl::desc(
+        "Min number of occurrences to consider a candidate for outlining."));
+static cl::opt<unsigned> MinInstructionLength(
+    "cso-min-instructions", cl::init(1), cl::Hidden,
+    cl::desc(
+        "Min number of instructions to consider a candidate for outlining."));
+static cl::opt<unsigned> MinBenefit(
+    "cso-min-benefit", cl::init(1), cl::Hidden,
+    cl::desc("Min estimated benefit to be considered profitable."));
+static cl::opt<unsigned>
+    EarlyPruningSize("cso-earlyprunesize", cl::init(6), cl::Hidden,
+                cl::desc("Instruction chain size for early pruning."));
+static cl::opt<bool>
+    EnableOutliner("enable-cso", cl::init(false), cl::Hidden,
+                   cl::desc("Enable outlining for code size."));
+static cl::opt<bool> DumpCC(
+    "cso-dump-cc", cl::init(false), cl::Hidden,
+    cl::desc("Dump information about the congruent between instructions."));
+
+#define DEBUG_TYPE "codesizeoutliner"
+STATISTIC(NumOccurrencesOutlined, "Number of occurrences outlined");
+STATISTIC(NumCandidatesOutlined, "Number of outlined functions created");
+
+namespace {
+/// \brief The information necessary to create an outlined function from a set
+/// of repeated instruction occurrences.
+struct OutlineCandidate {
+  /// Inputs into this candidate : Vector<Instr Index, Op#>.
+  std::vector<std::pair<size_t, size_t>> InputSeq;
+
+  /// Outputs from this candidate.
+  SparseBitVector<> Outputs;
+
+  /// The index of the output to fold into a return.
+  unsigned OutputToFold = -1;
+
+  /// The start index of each occurrence.
+  std::vector<unsigned> Occurrences;
+
+  /// The length of this sequence.
+  unsigned Len;
+
+  /// The computed benefit of outlining this candidate.
+  unsigned Benefit = 0;
+
+  /// The minimum number of occurrences needed to be beneficial.
+  unsigned MinBeneficialOccurCount = -1;
+
+  /// The length that this candidate shares with its successor.
+  unsigned SharedSizeWithNext = 0;
+
+  // Accessors.
+  using Iterator = std::vector<unsigned>::iterator;
+  Iterator begin() { return Occurrences.begin(); }
+  Iterator end() { return Occurrences.end(); }
+  size_t size() const { return Occurrences.size(); }
+
+  // Check to see if this chain is still profitable to outline.
+  bool isValid() const {
+    return MinBeneficialOccurCount != unsigned(-1);
+  }
+  // Set this candidate as not profitable.
+  void invalidate() { MinBeneficialOccurCount = -1; }
+  // Get the candidate at index /p Idx.
+  unsigned getOccurrence(size_t Idx) const {
+    assert(Idx < size() && "Invalid occurrence index.");
+    return Occurrences[Idx];
+  }
+  // Remove the occurrence at index /p Idx
+  void removeOccurrence(size_t Idx) {
+    Occurrences[Idx] = Occurrences.back();
+    Occurrences.pop_back();
+  }
+  OutlineCandidate(unsigned Len) : Len(Len) {}
+};
+
+/// \brief GVN Expression with relaxed equivalency constraints.
+class RelaxedExpression : public GVNExpression::Expression {
+public:
+  /// A special state for special equivalence constraints.
+  enum SpecialState { StructGep, ConstrainedCall, None };
+
+  RelaxedExpression(Instruction &I)
+      : Expression(GVNExpression::ET_Relaxed), Inst(&I),
+        SS(SpecialState::None) {
+    // Check the special state.
+    /// Struct geps require constant indices.
+    if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(&I)) {
+      if (gepContainsStructType(GEP))
+        SS = RelaxedExpression::StructGep;
+    } else if (CallInst *CI = dyn_cast<CallInst>(&I)) {
+      /// Don't take the address of inline asm calls.
+      if (CI->isInlineAsm())
+        SS = RelaxedExpression::ConstrainedCall;
+      /// Intrinsics and functions without exact definitions can not
+      ///  have their address taken.
+      else if (Function *F = CI->getCalledFunction()) {
+        if (!F->hasExactDefinition())
+          SS = RelaxedExpression::ConstrainedCall;
+      }
+    }
+  }
+  static bool classof(const GVNExpression::Expression *EB) {
+    GVNExpression::ExpressionType ET = EB->getExpressionType();
+    return ET == GVNExpression::ET_Relaxed;
+  }
+  bool equals(const GVNExpression::Expression &Other) const override {
+    const auto &OE = cast<RelaxedExpression>(Other);
+    if (SS != OE.SS)
+      return false;
+    // Handle calls separately to allow for mismatched tail calls.
+    if (CallInst *CI = dyn_cast<CallInst>(Inst)) {
+      const CallInst *RCI = cast<CallInst>(OE.Inst);
+      if (CI->getFunctionType() != RCI->getFunctionType() ||
+          CI->getNumOperands() != RCI->getNumOperands())
+        return false;
+      if (CI->getCallingConv() != RCI->getCallingConv() ||
+          CI->getAttributes() != RCI->getAttributes() ||
+          !CI->hasIdenticalOperandBundleSchema(*RCI))
+        return false;
+    } else if (!Inst->isSameOperationAs(OE.Inst,
+                                        Instruction::CompareIgnoringAlignment))
+      return false;
+    return checkSpecialEquivalence(OE);
+  }
+  // Special checks for instructions that have non generic equivalency.
+  bool checkSpecialEquivalence(const RelaxedExpression &Other) const {
+    const Instruction *OE = Other.Inst;
+    switch (Inst->getOpcode()) {
+    case Instruction::ShuffleVector: {
+      // LangRef : The shuffle mask operand is required to be a
+      //  constant vector with either constant integer or undef values.
+      return Inst->getOperand(2) == OE->getOperand(2);
+    }
+    case Instruction::Call: {
+      const CallInst *CI = cast<CallInst>(Inst);
+      const CallInst *OECI = cast<CallInst>(OE);
+      if (SS == ConstrainedCall)
+        return checkConstrainedCallEquivalence(CI, OECI);
+      break;
+    }
+    case Instruction::GetElementPtr: {
+      // Struct indices must be constant.
+      if (SS == StructGep)
+        return compareStructIndices(cast<GetElementPtrInst>(Inst),
+                                    cast<GetElementPtrInst>(OE));
+      break;
+    }
+    default:
+      break;
+    }
+    return true;
+  }
+  static bool checkConstrainedCallEquivalence(const CallInst *CI,
+                                              const CallInst *OECI) {
+    const Value *CIVal = CI->getCalledValue();
+    if (CIVal != OECI->getCalledValue())
+      return false;
+    if (const Function *CalledII = dyn_cast<Function>(CIVal)) {
+      switch (CalledII->getIntrinsicID()) {
+      case Intrinsic::memmove:
+      case Intrinsic::memcpy:
+      case Intrinsic::memset:
+        /// Alignment.
+        return CI->getArgOperand(3) == OECI->getArgOperand(3) &&
+               /// Volatile flag.
+               CI->getArgOperand(4) == OECI->getArgOperand(4);
+      case Intrinsic::objectsize:
+        /// Min.
+        return CI->getArgOperand(1) == OECI->getArgOperand(1) &&
+               /// Null unknown.
+               CI->getArgOperand(2) == OECI->getArgOperand(2);
+      case Intrinsic::expect:
+        /// Expected value.
+        return CI->getArgOperand(1) == OECI->getArgOperand(1);
+      case Intrinsic::prefetch:
+        /// RW.
+        return CI->getArgOperand(1) == OECI->getArgOperand(1) &&
+               /// Locality.
+               CI->getArgOperand(2) == OECI->getArgOperand(2) &&
+               /// Cache Type.
+               CI->getArgOperand(3) == OECI->getArgOperand(3);
+      case Intrinsic::ctlz:
+      case Intrinsic::cttz:
+        /// Is Zero Undef
+        return CI->getArgOperand(1) == OECI->getArgOperand(1);
+      default:
+        break;
+      }
+    }
+    return true;
+  }
+
+  static bool compareStructIndices(GetElementPtrInst *L,
+                                   const GetElementPtrInst *R) {
+    SmallVector<Value *, 8> GepIdxs(L->indices().begin(), L->indices().end());
+    GepIdxs.pop_back();
+    while (!GepIdxs.empty()) {
+      Type *PtrTy = L->getGEPReturnType(L->getPointerOperand(), GepIdxs);
+      if (PtrTy->isPointerTy() &&
+          PtrTy->getPointerElementType()->isStructTy()) {
+        unsigned OpNo = GepIdxs.size() + 1;
+        if (L->getOperand(OpNo) != R->getOperand(OpNo))
+          return false;
+      }
+      GepIdxs.pop_back();
+    }
+    return true;
+  }
+  // Check to see if the provided gep /p GEP indexes a struct type.
+  bool gepContainsStructType(GetElementPtrInst *GEP) {
+    Type *PtrTy = GEP->getPointerOperandType();
+    if (PtrTy->isPointerTy() && PtrTy->getPointerElementType()->isStructTy())
+      return true;
+
+    SmallVector<Value *, 8> GepIdxs(GEP->indices().begin(),
+                                    GEP->indices().end());
+    GepIdxs.pop_back();
+    while (!GepIdxs.empty()) {
+      PtrTy = GEP->getGEPReturnType(GEP->getPointerOperand(), GepIdxs);
+      if (PtrTy->isPointerTy() && PtrTy->getPointerElementType()->isStructTy())
+        return true;
+      GepIdxs.pop_back();
+    }
+    return false;
+  }
+
+  hash_code getHashValue() const override {
+    SmallVector<size_t, 8> HashRange;
+    HashRange.push_back(SS);
+    HashRange.push_back(Inst->getNumOperands());
+    HashRange.push_back(reinterpret_cast<size_t>(Inst->getType()));
+    for (auto &Op : Inst->operands())
+      HashRange.emplace_back(reinterpret_cast<size_t>(Op->getType()));
+    return hash_combine_range(HashRange.begin(), HashRange.end());
+  }
+
+private:
+  Instruction *Inst;
+  SpecialState SS;
+};
+
+/// \brief Helper struct containing mapping information for a module.
+class OutlinerModule {
+public:
+  ~OutlinerModule() { ExpressionAllocator.Reset(); }
+
+  ///
+  ///  Instruction Information Utilities.
+  ///
+
+  /// \brief Holds information about a particular instruction.
+  struct InstructionInfo {
+    /// The inputs/operands going into this instruction.
+    SmallVector<unsigned, 4> InputIndexes;
+
+    /// The index of the farthest use of this instruction in the same block
+    /// parent.
+    unsigned FarthestInSameBlockOutput = 0;
+
+    /// The size cost of this instruction.
+    unsigned Cost = -1;
+  };
+
+  // Get the instruction at index /p Idx.
+  Instruction *getInstr(unsigned Idx) { return InstrVec[Idx]; }
+  // Get the index of /p I inside of the internal vector.
+  unsigned getInstrIdx(Instruction *I) {
+    auto It = InstructionToIdxMap.find(I);
+    return LLVM_UNLIKELY(It == InstructionToIdxMap.end()) ? -1 : It->second;
+  }
+  // Get the parent function of the instruction at /p Idx.
+  Function *getInstrFunction(size_t Idx) {
+    assert(Idx < InstrVec.size() && "Invalid instruction index");
+    return InstrVec[Idx]->getFunction();
+  }
+  // Get or compute the cost of the instruction at /p InstrIdx.
+  unsigned getInstrCost(TargetTransformInfo &TTI, size_t InstrIdx) {
+    InstructionInfo *Info = InstrInfo[InstrIdx];
+    if (Info->Cost == unsigned(-1)) {
+      Instruction *I = InstrVec[InstrIdx];
+      Info->Cost = TTI.getUserCost(I);
+      // Be conservative about the cost of loads, on some platforms a load
+      //  can be folded. Estimating a lower cost helps to prevent over
+      //  estimating the benefit of this instruction.
+      if (isa<LoadInst>(I) && TTI.getAddressComputationCost(I->getType()) == 0)
+        --Info->Cost;
+    }
+    return Info->Cost;
+  }
+  // Get the instruction info attached to index /p InstrIdx
+  InstructionInfo &getInstrInfo(size_t InstrIdx) {
+    InstructionInfo *Info = InstrInfo[InstrIdx];
+    assert(Info && "Queried instruction has no info created.");
+    return *Info;
+  }
+  // Create instruction info for the instruction at /p InstrIdx
+  void createInstrInfo(size_t InstrIdx) {
+    InstructionInfo *&Info = InstrInfo[InstrIdx];
+    assert(!Info && "Instruction info already generated.");
+    Info = new (InfoAllocator.Allocate()) InstructionInfo();
+    Instruction *Inst = InstrVec[InstrIdx];
+
+    /// Inputs.
+    unsigned NumOperands = Inst->getNumOperands();
+    Info->InputIndexes.reserve(NumOperands);
+    for (unsigned InIt = 0; InIt < NumOperands; ++InIt) {
+      unsigned IIdx = 0;
+      Value *Op = Inst->getOperand(InIt);
+      assert(!isa<BasicBlock>(Op) && "Basic block inputs can not be handled.");
+      if (Instruction *I = dyn_cast<Instruction>(Op)) {
+        unsigned FoundIIdx = getInstrIdx(I);
+        if (FoundIIdx <= InstrIdx)
+          IIdx = FoundIIdx;
+      }
+      Info->InputIndexes.emplace_back(IIdx);
+    }
+
+    /// Outputs.
+    for (User *Usr : Inst->users()) {
+      Instruction *I = dyn_cast<Instruction>(Usr);
+      if (!I || I->getParent() != Inst->getParent()) {
+        Info->FarthestInSameBlockOutput = -1;
+        break;
+      }
+      unsigned IIdx = getInstrIdx(I);
+      if (IIdx > Info->FarthestInSameBlockOutput)
+        Info->FarthestInSameBlockOutput = IIdx;
+    }
+  }
+
+  ///
+  ///  Module Mapping Utilities.
+  ///
+
+  // Map the module /p M to prepare for outlining.
+  void mapModule(Module &M, bool FavorFastCode, ProfileSummaryInfo *PSI,
+                 function_ref<BlockFrequencyInfo &(Function &)> GetBFI) {
+    unsigned IllegalID = UINT_MAX;
+    bool HasProfileData = PSI->hasProfileSummary();
+
+    // Insert illegal ID at the front to act as a sentinel.
+    InstrVec.push_back(nullptr);
+    CCVec.push_back(IllegalID--);
+
+    for (Function &F : M) {
+      if (!F.hasExactDefinition() || F.hasGC() || F.isDefTriviallyDead())
+        continue;
+      if (F.hasFnAttribute(Attribute::OptimizeNone))
+        continue;
+      BlockFrequencyInfo *BFI = HasProfileData ? &GetBFI(F) : nullptr;
+      for (BasicBlock &BB : F) {
+        if (BB.isEHPad())
+          continue;
+
+        // Skip hot blocks if we have profile data.
+        if (HasProfileData)
+          if (FavorFastCode ? !PSI->isColdBB(&BB, BFI) : PSI->isHotBB(&BB, BFI))
+            continue;
+
+        // Try to map each instruction to a congruency id.
+        for (Instruction &I : BB) {
+          // Ignore debug info intrinsics.
+          if (isa<DbgInfoIntrinsic>(&I))
+            continue;
+          InstrVec.push_back(&I);
+          if (!canMapInstruction(&I)) {
+            CCVec.push_back(IllegalID--);
+            continue;
+          }
+          unsigned ICC = mapInstruction(I);
+          InstructionToIdxMap.try_emplace(&I, CCVec.size());
+          CCVec.push_back(ICC);
+        }
+      }
+    }
+    InstrInfo.assign(InstrVec.size(), nullptr);
+    if (DumpCC)
+      dumpCC(M);
+
+    // When building the suffix array when need to have a defined alphabet.
+    //  Therefore we need the indexes of illegal instructions to be within a
+    //  defined range, so we remap them starting from 1.
+    // NOTE: We could map them mixed in between the rest of the congruency
+    //   groups, but we force them to be the earliest congruency groups
+    //   because it produces better results during candidate selection.
+    unsigned Diff = (UINT_MAX - IllegalID);
+    for (unsigned &InstId : CCVec) {
+      if (InstId > IllegalID)
+        InstId = 1 + (UINT_MAX - InstId);
+      else
+        InstId += Diff;
+    }
+    CCID += Diff;
+
+    // REQUIRED: N-1 must be 0 to act as a sentinel for the suffix array
+    // algorithm.
+    CCVec.push_back(0);
+  }
+  // Get the unsigned vector representation of the congruencies for the module.
+  ArrayRef<unsigned> getCongruencyVector() const { return CCVec; }
+  // Get the number of different congruency classes found in the module.
+  unsigned getNumCongruencyClasses() const { return CCID; }
+  // Get the number of instructions mapped in this module.
+  unsigned getNumMappedInstructions() const { return InstrVec.size(); }
+
+private:
+  // Map the instruction /p I to a congruency class.
+  unsigned mapInstruction(Instruction &I) {
+    // We map each valid instruction to a Relaxed expression and use this for
+    // detecting congruency.
+    auto *E = new (ExpressionAllocator) RelaxedExpression(I);
+    // Assign a CC id to this instruction.
+    auto ItPair = GlobalCC[I.getOpcode()].try_emplace(E, CCID);
+    if (ItPair.second)
+      ++CCID;
+    return ItPair.first->second;
+  }
+  // Checks to see if a provided instruction /p I can be mapped.
+  bool canMapInstruction(Instruction *I) {
+    if (I->getOpcode() == Instruction::Call) {
+      CallInst *CI = cast<CallInst>(I);
+      // Be very conservative about musttail because it has additional
+      // guarantees that must be met.
+      if (CI->isMustTailCall())
+        return false;
+      // Be conservative about return twice calls.
+      if (CI->canReturnTwice())
+        return false;
+      CallSite CS(CI);
+      switch (CS.getIntrinsicID()) {
+      case Intrinsic::objectsize:
+      case Intrinsic::expect:
+      case Intrinsic::prefetch:
+      // Lib C functions are fine.
+      case Intrinsic::memcpy:
+      case Intrinsic::memmove:
+      case Intrinsic::memset:
+      case Intrinsic::sqrt:
+      case Intrinsic::pow:
+      case Intrinsic::powi:
+      case Intrinsic::sin:
+      case Intrinsic::cos:
+      case Intrinsic::exp:
+      case Intrinsic::exp2:
+      case Intrinsic::log:
+      case Intrinsic::log2:
+      case Intrinsic::log10:
+      case Intrinsic::fma:
+      case Intrinsic::fabs:
+      case Intrinsic::minnum:
+      case Intrinsic::maxnum:
+      case Intrinsic::copysign:
+      case Intrinsic::floor:
+      case Intrinsic::ceil:
+      case Intrinsic::trunc:
+      case Intrinsic::rint:
+      case Intrinsic::nearbyint:
+      case Intrinsic::round:
+      // Bit manipulation intrinsics.
+      case Intrinsic::bitreverse:
+      case Intrinsic::bswap:
+      case Intrinsic::ctpop:
+      case Intrinsic::ctlz:
+      case Intrinsic::cttz:
+        return true;
+      // Non intrinsics are fine if they don't have an inalloca arg.
+      case Intrinsic::not_intrinsic:
+        return !CS.hasInAllocaArgument();
+      default:
+        return false;
+      }
+      return true;
+    }
+    return !(isa<AllocaInst>(I) || isa<PHINode>(I) || isa<TerminatorInst>(I));
+  }
+  // Dump the mapped congruencies found for the module /p M.
+  void dumpCC(Module &M) {
+    for (Function &F : M) {
+      dbgs() << "function : " << F.getName() << "\n";
+      for (auto &BB : F) {
+        dbgs() << "block : " << BB.getName() << "\n";
+        for (Instruction &I : BB) {
+          auto It = InstructionToIdxMap.find(&I);
+          size_t Idx =
+              It == InstructionToIdxMap.end() ? -1 : CCVec[It->second];
+          dbgs() << "-- " << Idx << " : " << I << '\n';
+        }
+      }
+    }
+    for (auto &CCIt : GlobalCC) {
+      for (auto CC : CCIt) {
+        size_t Idx = CC.second;
+        dbgs() << "-- Examining CC ID : " << Idx << "\n";
+        for (size_t i = 0, e = CCVec.size(); i < e; ++i)
+          if (CCVec[i] == Idx)
+            dbgs() << " - " << *InstrVec[i] << "\n";
+        dbgs() << "\n";
+      }
+    }
+  }
+
+  /// Internal vector representation of the instructions within the mapped
+  /// module.
+  std::vector<unsigned> CCVec;
+
+  /// Stores location of instructions mapped to the corresponding index in
+  ///  the CCVec.
+  std::vector<Instruction *> InstrVec;
+
+  /// Stores information for parallel instruction in InstrVec.
+  std::vector<InstructionInfo *> InstrInfo;
+  SpecificBumpPtrAllocator<InstructionInfo> InfoAllocator;
+
+  /// Map<Instruction, Index in CCVec>
+  DenseMap<Instruction *, unsigned> InstructionToIdxMap;
+
+  /// Current Congruency ID.
+  unsigned CCID = 1;
+
+  /// Mapping of expression to congruency id.
+  std::array<DenseMap<const GVNExpression::Expression *, unsigned>,
+             Instruction::OtherOpsEnd>
+      GlobalCC;
+
+  /// Memory management for the GVN expressions used for congruency.
+  mutable BumpPtrAllocator ExpressionAllocator;
+};
+
+/// \brief Cache output allocas created during outlining and reuse them.
+class OutputAllocaCache {
+public:
+  // Get an alloca for type /p Ty in function /p F that has an array
+  //  count of atleast /p Count.
+  AllocaInst *getFreeAlloca(Function *F, Type *Ty, unsigned Count) {
+    if (AllocaInst *NewAI = findAndUpdate(F, Ty, Count))
+      return NewAI;
+    // Create the new alloca inst.
+    Instruction *AllocaInsertPnt = &F->getEntryBlock().front();
+    Value *AllocSize =
+        ConstantInt::get(Type::getInt32Ty(Ty->getContext()), Count);
+    unsigned AddrSpace = Ty->isPointerTy() ? Ty->getPointerAddressSpace() : 0;
+    AllocaInst *NewAlloca =
+        new AllocaInst(Ty, AddrSpace, AllocSize, "", AllocaInsertPnt);
+    DenseMap<Type *, AllocaInst *> &TyMap = FunctionToAllocaCache[F];
+    TyMap.try_emplace(Ty, NewAlloca);
+    return NewAlloca;
+  }
+
+private:
+  // Try to find an existing alloca an update the count if needed.
+  AllocaInst *findAndUpdate(Function *F, Type *Ty, unsigned Count) {
+    AllocaInst *AI = nullptr;
+    DenseMap<Type *, AllocaInst *> &TyMap = FunctionToAllocaCache[F];
+    auto It = TyMap.find(Ty);
+    if (It != TyMap.end()) {
+      AI = It->second;
+      ConstantInt *CI = cast<ConstantInt>(AI->getArraySize());
+      if (Count > CI->getZExtValue())
+        AI->setOperand(0, ConstantInt::get(CI->getType(), Count));
+    }
+    return AI;
+  }
+
+  /// Map<Function, Map<Alloca Type, Allocation Inst>>
+  DenseMap<Function *, DenseMap<Type *, AllocaInst *>> FunctionToAllocaCache;
+};
+
+/// \brief A specific instance of an outlined candidate.
+struct FunctionSplicer {
+  FunctionSplicer(bool EmitProfileData) : EmitProfileData(EmitProfileData) {
+    // Prepare the function attributes that we don't want to inherit from any
+    // parents.
+    NonInheritAttrs.addAttribute(Attribute::AlwaysInline);
+    NonInheritAttrs.addAttribute(Attribute::ArgMemOnly);
+    NonInheritAttrs.addAttribute(Attribute::InaccessibleMemOnly);
+    NonInheritAttrs.addAttribute(Attribute::InaccessibleMemOrArgMemOnly);
+    NonInheritAttrs.addAttribute(Attribute::InlineHint);
+    NonInheritAttrs.addAttribute(Attribute::Naked);
+    NonInheritAttrs.addAttribute(Attribute::NoInline);
+    NonInheritAttrs.addAttribute(Attribute::NoRecurse);
+    NonInheritAttrs.addAttribute(Attribute::ReturnsTwice);
+    NonInheritAttrs.addAttribute(Attribute::ReadOnly);
+    NonInheritAttrs.addAttribute(Attribute::ReadNone);
+    NonInheritAttrs.addAttribute(Attribute::NoReturn);
+    NonInheritAttrs.addAttribute(Attribute::WriteOnly);
+  }
+  // Reset the outliner to prepare for a new instance.
+  void prepareForNewInstance(OutlineCandidate &OC, OutlinerModule &OM,
+                             unsigned FirstValidOccur) {
+    OutlinedFn = nullptr;
+    OutputTypeCount.clear();
+    OutputGepIdx.clear();
+    InitialStartIdx = OC.getOccurrence(FirstValidOccur);
+    if (OC.Outputs.count() < 2)
+      return;
+    // Collect information about the outputs of this new candidate.
+    // Output parameters are condensed by type, so we need to build the
+    //  offset from the base pointer for each output.
+    for (size_t OutputIdx : OC.Outputs) {
+      if (OutputIdx == OC.OutputToFold)
+        continue;
+      Type *OutTy = OM.getInstr(InitialStartIdx + OutputIdx)->getType();
+      unsigned GepIdx, TyArgNo;
+      auto TyCountIt = OutputTypeCount.find(OutTy);
+      if (TyCountIt == OutputTypeCount.end()) {
+        GepIdx = 0;
+        TyArgNo = OutputTypeCount.size();
+        OutputTypeCount.try_emplace(OutTy, 1, TyArgNo);
+      } else {
+        GepIdx = TyCountIt->second.first++;
+        TyArgNo = TyCountIt->second.second;
+      }
+      OutputGepIdx.try_emplace(OutputIdx, TyArgNo, GepIdx);
+    }
+  }
+
+  // Outline a new occurrence of an outline chain.
+  void outlineOccurrence(OutlineCandidate &OC, size_t StartIdx,
+                         OutlinerModule &OM) {
+    ++NumOccurrencesOutlined;
+    Instruction *Tail = OM.getInstr(StartIdx + (OC.Len - 1));
+    Function *ParentFn = Tail->getFunction();
+    bool InitialOccur = !OutlinedFn;
+
+    /// Split the outline chain into its own block.
+    Instruction *Head = OM.getInstr(StartIdx);
+    BasicBlock *EntryBlock = Head->getParent();
+    // Split our chain instance into a separate block for extraction.
+    /// Split up to the head if we aren't at the front of our block.
+    if (Head != &EntryBlock->front() ||
+        EntryBlock == &ParentFn->getEntryBlock())
+      EntryBlock = EntryBlock->splitBasicBlock(Head->getIterator());
+    /// Split after the tail.
+    auto SentinalIt = Tail->getNextNode()->getIterator();
+    BasicBlock *Exit = EntryBlock->splitBasicBlock(SentinalIt);
+
+    // Create a new block to patch the outlined section.
+    BasicBlock *OutlineBlock =
+        BasicBlock::Create(ParentFn->getContext(), "cso.patch", ParentFn);
+
+    // Create parameter vec for the new call.
+    unsigned NumOutputs = OC.Outputs.count();
+    std::vector<Value *> Args;
+    Args.reserve(OC.InputSeq.size() + NumOutputs);
+
+    // Build inputs/outputs in order.
+    for (size_t i = 0, e = OC.InputSeq.size(); i < e; ++i) {
+      size_t InstrIdx, OpNo;
+      std::tie(InstrIdx, OpNo) = OC.InputSeq[i];
+      Args.push_back(OM.getInstr(StartIdx + InstrIdx)->getOperand(OpNo));
+    }
+
+    // Replace uses of outputs and create reloads.
+    if (NumOutputs > 0) {
+      SmallVector<Value *, 4> OutputArgs(OutputTypeCount.size());
+      for (auto &ArgPair : OutputTypeCount) {
+        unsigned ArgNo, Count;
+        std::tie(Count, ArgNo) = ArgPair.second;
+        OutputArgs[ArgNo] = OAC.getFreeAlloca(ParentFn, ArgPair.first, Count);
+      }
+      Args.insert(Args.end(), OutputArgs.begin(), OutputArgs.end());
+      for (size_t OutputIdx : OC.Outputs) {
+        if (OutputIdx == OC.OutputToFold)
+          continue;
+        Instruction *Out = OM.getInstr(StartIdx + OutputIdx);
+        unsigned ArgNo, GepIdx;
+        std::tie(ArgNo, GepIdx) = OutputGepIdx[OutputIdx];
+        Value *OutputArg = OutputArgs[ArgNo];
+        if (GepIdx != 0) {
+          Value *Idx =
+              ConstantInt::get(Type::getInt32Ty(Out->getContext()), GepIdx);
+          OutputArg = GetElementPtrInst::Create(Out->getType(), OutputArg, Idx,
+                                                "", OutlineBlock);
+        }
+        Value *Reload = new LoadInst(OutputArg, "", OutlineBlock);
+        Out->replaceUsesOutsideBlock(Reload, EntryBlock);
+      }
+      if (!InitialOccur) {
+        Instruction *Out = OM.getInstr(StartIdx + OC.OutputToFold);
+        Out->removeFromParent();
+        Out->dropAllReferences();
+      }
+    }
+
+    // Replace branches to entry block.
+    EntryBlock->replaceAllUsesWith(OutlineBlock);
+    BranchInst::Create(Exit, OutlineBlock);
+
+    // Get the first valid debug info.
+    DebugLoc CallLoc;
+    if (ParentFn->getSubprogram())
+      for (Instruction *I = Head; !I->isTerminator() && !CallLoc;
+           I = I->getNextNode())
+        CallLoc = I->getDebugLoc();
+
+    // If this is the first occurrence then we outline the chain, otherwise we
+    // erase the entry block because it's dead.
+    if (OutlinedFn) {
+      SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;
+      for (unsigned InitI = InitialStartIdx, CurI = StartIdx,
+                    InitE = InitialStartIdx + OC.Len;
+           InitI < InitE; ++InitI, ++CurI) {
+        Instruction *InitII = OM.getInstr(InitI);
+        Instruction *CurII = OM.getInstr(CurI);
+        // Make sure the alignment is valid as we skip it during congruency
+        // finding.
+        if (LoadInst *LI = dyn_cast<LoadInst>(InitII))
+          LI->setAlignment(
+              std::min(LI->getAlignment(),
+                       cast<LoadInst>(CurII)->getAlignment()));
+        else if (StoreInst *SI = dyn_cast<StoreInst>(InitII))
+          SI->setAlignment(
+              std::min(SI->getAlignment(),
+                       cast<StoreInst>(CurII)->getAlignment()));
+        // Make sure that no tails are propagated properly.
+        else if (CallInst *CI = dyn_cast<CallInst>(InitII)) {
+          if (cast<CallInst>(CurII)->isNoTailCall())
+            CI->setTailCallKind(CallInst::TCK_NoTail);
+        }
+        // Be conservative about flags like nsw/nuw.
+        else
+          InitII->andIRFlags(OM.getInstr(CurI));
+
+        // Merge metadata.
+        InitII->getAllMetadata(MDs);
+        for(auto &MDPair : MDs)
+          if(CurII->getMetadata(MDPair.first) != MDPair.second)
+            InitII->setMetadata(MDPair.first, nullptr);
+      }
+      EntryBlock->eraseFromParent();
+      AttributeFuncs::mergeAttributesForInlining(*OutlinedFn, *ParentFn);
+    } else
+      outlineInitialOccurrence(OC, OM, StartIdx, Args, EntryBlock);
+
+    // Create the patchup for the outline section.
+    CallInst *CI =
+        CallInst::Create(OutlinedFn, Args, "", &OutlineBlock->front());
+    if (OC.OutputToFold != unsigned(-1)) {
+      Instruction *FoldedOut = OM.getInstr(StartIdx + OC.OutputToFold);
+      if (InitialOccur)
+        FoldedOut->replaceUsesOutsideBlock(CI, FoldedOut->getParent());
+      else {
+        FoldedOut->replaceAllUsesWith(CI);
+        FoldedOut->deleteValue();
+      }
+    }
+    CI->setDebugLoc(CallLoc);
+  }
+
+  // \brief Finalize this function as an outline instance. In this step we
+  // re-unique the inputs to the function.
+  void finalize(OutlineCandidate &OC) {
+    FunctionType *CurFnTy = OutlinedFn->getFunctionType();
+    unsigned NumInputs = OC.InputSeq.size();
+
+    // Map <ArgNo> to <Congruency Group Idx>
+    DenseMap<unsigned, unsigned> ArgNoToCG, RhsArgNoToCG;
+    std::vector<BitVector> ArgCongruencyGroups, RhsArgCGroups;
+
+    // Helper function to collect the information on the use of inputs in the
+    // outlined function. This identifies which arguments are actually congruent
+    // to each other for a specific function call.
+    auto CollectInputInfo = [&](CallInst *CI,
+                                DenseMap<unsigned, unsigned> &ANoToCG,
+                                std::vector<BitVector> &ArgCGroups) {
+      ArgCGroups.reserve(NumInputs);
+      for (unsigned i = 0, e = NumInputs; i < e; ++i) {
+        // We already evaluated the equivalencies for this arg.
+        if (ANoToCG.count(i))
+          continue;
+        Value *Op = CI->getOperand(i);
+        BitVector CurrentGroup(NumInputs);
+        CurrentGroup.set(i);
+        ANoToCG.try_emplace(i, ArgCGroups.size());
+        for (unsigned j = i + 1; j < e; ++j) {
+          if (ANoToCG.count(j))
+            continue;
+          if (CI->getArgOperand(j) == Op) {
+            CurrentGroup.set(j);
+            ANoToCG.try_emplace(j, ArgCGroups.size());
+          }
+        }
+        ArgCGroups.emplace_back(std::move(CurrentGroup));
+      }
+    };
+
+    // Build initial equivalences from the first call.
+    auto UserIt = OutlinedFn->user_begin();
+    CallInst *FirstCI = cast<CallInst>(*UserIt);
+    ++UserIt;
+    CollectInputInfo(FirstCI, ArgNoToCG, ArgCongruencyGroups);
+
+    // If we have the same amount of congruency groups as we do arguments,
+    //   the they are already unique.
+    if (NumInputs == ArgCongruencyGroups.size())
+      return;
+    // Check every other user to see if the equivalencies hold up.
+    BitVector ResolvedInputs(NumInputs);
+    // BitVector helper to hold non congruent matches between argument groups.
+    BitVector NonCongruentLeft;
+    for (auto UserE = OutlinedFn->user_end(); UserIt != UserE; ++UserIt) {
+      CallInst *CI = cast<CallInst>(*UserIt);
+      RhsArgCGroups.clear();
+      RhsArgNoToCG.clear();
+      CollectInputInfo(CI, RhsArgNoToCG, RhsArgCGroups);
+      ResolvedInputs.reset();
+      for (unsigned i = 0, e = NumInputs; i < e; ++i) {
+        if (ResolvedInputs.test(i))
+          continue;
+        BitVector &LhsGroup = ArgCongruencyGroups[ArgNoToCG[i]];
+        BitVector &RhsGroup = RhsArgCGroups[RhsArgNoToCG[i]];
+
+        /// Build non congruent arguments between the groups.
+        NonCongruentLeft = LhsGroup;
+        /// Congruent matches.
+        LhsGroup &= RhsGroup;
+        assert(LhsGroup.count() > 0);
+
+        // Non congruent sets on both sides still act as a congruency group.
+        NonCongruentLeft ^= LhsGroup;
+
+        // Mark arguments as handled.
+        for (unsigned SetBit : LhsGroup.set_bits())
+          ResolvedInputs.set(SetBit);
+        if (NonCongruentLeft.count() == 0)
+          continue;
+
+        // Move the non congruent matches from the left group to a
+        //   new congruency group.
+        unsigned NewGroupId = ArgCongruencyGroups.size();
+        ArgCongruencyGroups.emplace_back(std::move(NonCongruentLeft));
+
+        // Move non congruent matches to a new congruency group
+        //   and remove them from the top level mapping.
+        for (unsigned SetBit : ArgCongruencyGroups.back().set_bits())
+          ArgNoToCG[SetBit] = NewGroupId;
+      }
+    }
+
+    // No inputs can be condensed.
+    if (NumInputs == ArgCongruencyGroups.size())
+      return;
+
+    // Build new function from the condensed inputs.
+    std::vector<Type *> NewFnTys;
+    for (auto &It : ArgCongruencyGroups)
+      NewFnTys.push_back(CurFnTy->getParamType(It.find_first()));
+    for (unsigned i = NumInputs, e = CurFnTy->getNumParams(); i < e; ++i)
+      NewFnTys.push_back(CurFnTy->getParamType(i));
+
+    // Create the merged function.
+    FunctionType *NewFnTy =
+        FunctionType::get(CurFnTy->getReturnType(), NewFnTys, false);
+    Function *MergedFn = Function::Create(NewFnTy, OutlinedFn->getLinkage(), "",
+                                          OutlinedFn->getParent());
+    MergedFn->takeName(OutlinedFn);
+    MergedFn->copyAttributesFrom(OutlinedFn);
+    DenseMap<Argument *, Value *> ValMap;
+
+    // Remap the arguments.
+    auto ArgI = OutlinedFn->arg_begin();
+    for (size_t i = 0, e = NumInputs; i < e; ++i, ++ArgI)
+      ValMap[&*ArgI] = std::next(MergedFn->arg_begin(), ArgNoToCG[i]);
+    auto MergeArgI =
+        std::next(MergedFn->arg_begin(), ArgCongruencyGroups.size());
+    for (size_t i = NumInputs, e = CurFnTy->getNumParams(); i < e;
+         ++i, ++ArgI, ++MergeArgI) {
+      ValMap[&*ArgI] = &*MergeArgI;
+    }
+    /// Move Fn Body.
+    MergedFn->getBasicBlockList().splice(MergedFn->begin(),
+                                         OutlinedFn->getBasicBlockList());
+    /// Remap arguments.
+    for (Argument &A : OutlinedFn->args()) {
+      auto NewArgIt = ValMap.find(&A);
+      if (NewArgIt != ValMap.end())
+        A.replaceAllUsesWith(NewArgIt->second);
+    }
+
+    // Rewrite the calls to this function with calls to the merged function.
+    std::vector<Value *> CallArgs;
+    for (auto U = OutlinedFn->use_begin(), E = OutlinedFn->use_end(); U != E;) {
+      CallInst *CI = dyn_cast<CallInst>(U->getUser());
+      ++U;
+      CallArgs.clear();
+      /// Map call args by their congruency group.
+      for (auto &It : ArgCongruencyGroups)
+        CallArgs.push_back(CI->getArgOperand(It.find_first()));
+      /// Outputs are retained, except for the promoted value.
+      for (unsigned i = NumInputs, e = CurFnTy->getNumParams(); i < e; ++i)
+        CallArgs.push_back(CI->getArgOperand(i));
+      CallInst *NewCall = CallInst::Create(MergedFn, CallArgs, "", CI);
+      NewCall->setDebugLoc(CI->getDebugLoc());
+      CI->replaceAllUsesWith(NewCall);
+      CI->eraseFromParent();
+    }
+    OutlinedFn->eraseFromParent();
+  }
+
+private:
+  // \brief Outline the initial occurrence of this chain.
+  void outlineInitialOccurrence(OutlineCandidate &OC, OutlinerModule &OM,
+                                size_t StartIdx, ArrayRef<Value *> Args,
+                                BasicBlock *Entry) {
+    /// Function type for outlined function.
+    std::vector<Type *> Tys;
+    Tys.reserve(Args.size());
+    for (Value *Arg : Args)
+      Tys.push_back(Arg->getType());
+    LLVMContext &Ctx = Entry->getContext();
+    Instruction *FoldedOut = nullptr;
+    Type *OutputTy = Type::getVoidTy(Ctx);
+    if (OC.OutputToFold != unsigned(-1)) {
+      FoldedOut = OM.getInstr(StartIdx + OC.OutputToFold);
+      OutputTy = FoldedOut->getType();
+    }
+    FunctionType *FTy = FunctionType::get(OutputTy, Tys, false);
+    Function *ParentFn = Entry->getParent();
+
+    /// Create function and move blocks.
+    OutlinedFn = Function::Create(FTy, GlobalValue::PrivateLinkage, "cso",
+                                  Entry->getModule());
+    OutlinedFn->getBasicBlockList().splice(
+        OutlinedFn->end(), Entry->getParent()->getBasicBlockList(),
+        Entry->getIterator());
+    OutlinedFn->setUnnamedAddr(GlobalValue::UnnamedAddr::Local);
+    Entry->getTerminator()->eraseFromParent();
+    ReturnInst::Create(Ctx, FoldedOut, Entry);
+
+    // FIXME: Fix this if we can have merged debug info.
+    if (ParentFn->getSubprogram()) {
+      for (auto It = Entry->begin(), E = Entry->end(); It != E;) {
+        Instruction &I = *It;
+        ++It;
+        if (isa<DbgInfoIntrinsic>(I))
+          Entry->getInstList().erase(I.getIterator());
+      }
+    }
+
+    // FIXME: Ideally we should compute the real count for this function but
+    //  for now we just tag it as cold.
+    if (EmitProfileData)
+      OutlinedFn->addFnAttr(Attribute::Cold);
+
+    /// Create stores for any output variables.
+    auto OutputArgBegin = OutlinedFn->arg_begin();
+    std::advance(OutputArgBegin, OC.InputSeq.size());
+    for (size_t OutputIdx : OC.Outputs) {
+      if (OutputIdx == OC.OutputToFold)
+        continue;
+      unsigned ArgNo, GepIdx;
+      std::tie(ArgNo, GepIdx) = OutputGepIdx[OutputIdx];
+      Value *OutputArg = &*std::next(OutputArgBegin, ArgNo);
+      Instruction *Out = OM.getInstr(StartIdx + OutputIdx);
+      Instruction *InstPtr = Out->getNextNode();
+      if (GepIdx != 0) {
+        Value *Idx =
+            ConstantInt::get(Type::getInt32Ty(Out->getContext()), GepIdx);
+        OutputArg = GetElementPtrInst::Create(Out->getType(), OutputArg, Idx,
+                                              "", InstPtr);
+      }
+      new StoreInst(Out, OutputArg, InstPtr);
+    }
+
+    /// Replace input operands with function arguments.
+    auto ArgI = OutlinedFn->arg_begin();
+    for (auto &InputPair : OC.InputSeq) {
+      size_t InputInstIdx, OpNo;
+      std::tie(InputInstIdx, OpNo) = InputPair;
+      Instruction *InputInst = OM.getInstr(StartIdx + InputInstIdx);
+      InputInst->setOperand(OpNo, &*ArgI++);
+    }
+
+    /// Inherit attributes.
+    OutlinedFn->addAttributes(
+        AttributeList::FunctionIndex,
+        ParentFn->getAttributes().getAttributes(AttributeList::FunctionIndex));
+    OutlinedFn->removeAttributes(AttributeList::FunctionIndex, NonInheritAttrs);
+    OutlinedFn->removeFnAttr(Attribute::AllocSize);
+  }
+  // The function created after outlining.
+  Function *OutlinedFn = nullptr;
+  // Output relocation information.
+  DenseMap<Type *, std::pair<unsigned, unsigned>> OutputTypeCount;
+  DenseMap<unsigned, std::pair<unsigned, unsigned>> OutputGepIdx;
+  OutputAllocaCache OAC;
+  // Set of attributes that are not to be inherited from parent functions.
+  AttrBuilder NonInheritAttrs;
+  // If we are emitting profile date during outlining.
+  bool EmitProfileData;
+  // The index of the initial occurrence for the current splice.
+  unsigned InitialStartIdx;
+};
+
+/// \brief Perform analysis and verification for the found outline candidates.
+struct OutlinerAnalysisImpl {
+  OutlinerAnalysisImpl(OutlinerModule &OM,
+                       std::vector<OutlineCandidate> &CandidateList,
+                       function_ref<TargetTransformInfo &(Function &)> GetTTI,
+                       const DataLayout *Layout)
+      : OM(OM), CandidateList(CandidateList), GetTTI(GetTTI), Layout(Layout) {}
+
+  // Analyze our found candidates for benefit and correctness.
+  void analyzeCandidateList() {
+    // Generate instruction info for each instruction that is part
+    //  of an occurrence.
+    BitVector OccurInstrInfo(OM.getNumMappedInstructions());
+    for (OutlineCandidate &OC : CandidateList)
+      for (unsigned Occur : OC)
+        OccurInstrInfo.set(Occur, Occur + OC.Len);
+    for (unsigned Idx : OccurInstrInfo.set_bits())
+      OM.createInstrInfo(Idx);
+
+    // Estimate the function type and benefit of each chain.
+    estimateFunctionType(0, CandidateList.size());
+
+    // After initial benefit analysis, we verify the occurrences of each
+    // candidate are compatible.
+    verifyOccurrenceCompatability();
+  }
+
+private:
+  // Helper struct for verifying the compatibility of occurrences within a
+  // candidate.
+  struct VerifyInst : public std::pair<Function *, std::vector<unsigned>> {
+    void reset(Function *F) {
+      first = F;
+      second.clear();
+    }
+    bool compare(VerifyInst &R,
+                 function_ref<TargetTransformInfo &(Function &)> GetTTI) {
+      Function *LF = first, *RF = R.first;
+      if (LF != RF) {
+        if (!AttributeFuncs::areInlineCompatible(*LF, *RF))
+          return false;
+        TargetTransformInfo &TTI = GetTTI(*LF);
+        if (!TTI.areInlineCompatible(LF, RF))
+          return false;
+      }
+      return second == R.second;
+    }
+  };
+
+  // Verify the compatibilities of the occurrences in each candidate.
+  void verifyOccurrenceCompatability() {
+    // Vector of different verification leaders.
+    std::vector<VerifyInst> VerificationCands;
+    // Count of occurrences to an verification instance.
+    std::vector<size_t> Counts;
+    // Maps occurrences to the input index they belong to.
+    std::vector<size_t> OccurrenceInputIdx;
+    // Verification instance of the current occurrence being considered.
+    VerifyInst CurrentOccurVerifyInst;
+
+    size_t CurrentCandidateListSize = CandidateList.size();
+    for (size_t i = 0, e = CurrentCandidateListSize; i < e; ++i) {
+      OutlineCandidate &OC = CandidateList[i];
+      if (!OC.isValid())
+        continue;
+      // Compute the input sequence for this occurrence.
+      for (size_t Oi = OccurrenceInputIdx.size(), Oe = OC.size(); Oi < Oe;
+           ++Oi) {
+        unsigned Occur = OC.getOccurrence(Oi);
+        CurrentOccurVerifyInst.reset(OM.getInstrFunction(Occur));
+        for (size_t InstrIdx = Occur, InstrE = Occur + OC.Len;
+             InstrIdx < InstrE; ++InstrIdx) {
+          OutlinerModule::InstructionInfo &II = OM.getInstrInfo(InstrIdx);
+          for (unsigned InIdx : II.InputIndexes) {
+            // We only really need to verify inputs coming from within the
+            // sequence. Other inputs simply help to verify the ordering.
+            unsigned InputIdx = InIdx < Occur ? -1 : InIdx - Occur;
+            CurrentOccurVerifyInst.second.push_back(InputIdx);
+          }
+        }
+
+        // Check for existing mapping of this instance.
+        auto It =
+            std::find_if(VerificationCands.begin(), VerificationCands.end(),
+                         [&](VerifyInst &L) {
+                           return L.compare(CurrentOccurVerifyInst, GetTTI);
+                         });
+        if (It != VerificationCands.end()) {
+          size_t InternalInputIt = It - VerificationCands.begin();
+          ++Counts[InternalInputIt];
+          OccurrenceInputIdx.push_back(InternalInputIt);
+        } else {
+          unsigned OrigCapacity = CurrentOccurVerifyInst.second.capacity();
+          OccurrenceInputIdx.push_back(VerificationCands.size());
+          VerificationCands.emplace_back(std::move(CurrentOccurVerifyInst));
+          CurrentOccurVerifyInst.second.reserve(OrigCapacity);
+          Counts.push_back(1);
+        }
+      }
+
+      OutlineCandidate &Cur = CandidateList[i];
+      size_t SharedSizeWithNext = Cur.SharedSizeWithNext;
+      size_t IdxOfNext = i + 1;
+      while (SharedSizeWithNext > 0 && !CandidateList[IdxOfNext].isValid())
+        SharedSizeWithNext = CandidateList[IdxOfNext++].SharedSizeWithNext;
+      size_t FirstOccur = Cur.getOccurrence(0);
+
+      // Only split if needed.
+      if (Counts.size() > 1)
+        splitOutlineChain(i, Counts, OccurrenceInputIdx);
+
+      // If we share a size with the next chain then we do cleanup and set up to
+      //  reduce the amount of work we need to do during the next iteration.
+      if (SharedSizeWithNext > 0 && CandidateList[IdxOfNext].isValid()) {
+        // Get the cut off point for moving to the next candidate.
+        size_t SharedCutOffPoint = 0;
+        for (size_t InstrIdx = FirstOccur,
+                    InstrE = FirstOccur + SharedSizeWithNext;
+             InstrIdx < InstrE; ++InstrIdx) {
+          OutlinerModule::InstructionInfo &II = OM.getInstrInfo(InstrIdx);
+          SharedCutOffPoint += II.InputIndexes.size();
+        }
+
+        // Update the size of the internal inputs vectors.
+        for (size_t InIt = 0, InE = VerificationCands.size(); InIt < InE;
+             ++InIt)
+          VerificationCands[InIt].second.resize(SharedCutOffPoint);
+
+        // Don't bother merging if there is only one instance.
+        if (Counts.size() == 1)
+          continue;
+
+        // Set resolved occurrences that point to the first vector.
+        BitVector UnResolved(OccurrenceInputIdx.size(), true);
+        for (size_t i = 0, e = OccurrenceInputIdx.size(); i < e; ++i)
+          if (OccurrenceInputIdx[i] == 0)
+            UnResolved.reset(i);
+        // Condense the internal inputs vector in the case where two vectors are
+        //  now equivalent given the smaller size.
+        size_t InsertIdx = 1;
+        for (size_t i = 1, e = VerificationCands.size(); i < e; ++i) {
+          VerifyInst &VI = VerificationCands[i];
+          auto RemapOccurIdxs = [&](size_t Old, size_t New) {
+            for (size_t OccurIdx : UnResolved.set_bits()) {
+              if (OccurrenceInputIdx[OccurIdx] == Old) {
+                OccurrenceInputIdx[OccurIdx] = New;
+                UnResolved.reset(OccurIdx);
+              }
+            }
+          };
+          // Try to remap to an existing instance.
+          auto Remap = [&]() -> bool {
+            for (size_t j = 0; j < InsertIdx; ++j) {
+              if (VerificationCands[j].compare(VI, GetTTI)) {
+                Counts[j] += Counts[i];
+                RemapOccurIdxs(i, j);
+                return true;
+              }
+            }
+            return false;
+          };
+
+          // Update mapping with new instance.
+          if (!Remap()) {
+            if (i != InsertIdx) {
+              Counts[InsertIdx] = Counts[i];
+              RemapOccurIdxs(i, InsertIdx);
+              VerificationCands[InsertIdx++] = std::move(VerificationCands[i]);
+            } else
+              ++InsertIdx;
+          }
+        }
+        VerificationCands.resize(InsertIdx);
+        Counts.resize(InsertIdx);
+        continue;
+      }
+      // Otherwise we just cleanup what we used.
+      VerificationCands.clear();
+      Counts.clear();
+      OccurrenceInputIdx.clear();
+    }
+    estimateFunctionType(CurrentCandidateListSize, CandidateList.size());
+  }
+
+  // Split the OutlineChain at index /p CurrentChainIndex into N different
+  // chains with the provided memberships.
+  void splitOutlineChain(size_t CurrentChainIndex,
+                         const std::vector<size_t> &MembershipCounts,
+                         const std::vector<size_t> &OccurrenceInputIdx) {
+    OutlineCandidate *OrigChain = &CandidateList[CurrentChainIndex];
+    SmallVector<size_t, 4> SplitChains(MembershipCounts.size(), -1);
+    size_t FirstValid = 0;
+    while (FirstValid < MembershipCounts.size() &&
+           MembershipCounts[FirstValid] < MinOccurrences)
+      ++FirstValid;
+    if (FirstValid == MembershipCounts.size()) {
+      OrigChain->invalidate();
+      return;
+    }
+
+    SplitChains[FirstValid] = CurrentChainIndex;
+
+    // Add new chains for each valid count after the first.
+    for (size_t i = FirstValid + 1, e = MembershipCounts.size(); i < e; ++i) {
+      size_t Count = MembershipCounts[i];
+      if (Count < MinOccurrences)
+        continue;
+      SplitChains[i] = CandidateList.size();
+      CandidateList.emplace_back(OrigChain->Len);
+      OutlineCandidate &NewChain = CandidateList.back();
+      NewChain.Occurrences.reserve(Count);
+      NewChain.InputSeq.reserve(OrigChain->InputSeq.capacity());
+    }
+
+    // Move occurrences to their new parents.
+    OrigChain = &CandidateList[CurrentChainIndex];
+    for (size_t i = 0, e = OrigChain->size(); i < e; ++i) {
+      size_t NewParentIdx = SplitChains[OccurrenceInputIdx[i]];
+      if (NewParentIdx != CurrentChainIndex && NewParentIdx != size_t(-1)) {
+        OutlineCandidate &NewParent = CandidateList[NewParentIdx];
+        NewParent.Occurrences.push_back(OrigChain->Occurrences[i]);
+      }
+    }
+    bool RecomputeInputs = FirstValid != 0;
+    for (ssize_t i = OrigChain->size() - 1; i >= 0; --i)
+      if (OccurrenceInputIdx[i] != FirstValid)
+        OrigChain->removeOccurrence(i);
+
+    // Update the occurrences and recalculate the analysis for the split
+    // candidate.
+    computeInputOutputSequence(*OrigChain, RecomputeInputs);
+    estimateFunctionType(CurrentChainIndex, CurrentChainIndex + 1);
+  }
+
+  // Estimate the function type of each outline chain in the given range.
+  void estimateFunctionType(size_t StartIdx, size_t EndIdx) {
+    std::vector<Value *> InputOperands;
+    BitVector UnFoldableInputs;
+    for (size_t i = StartIdx; i < EndIdx; ++i) {
+      OutlineCandidate &OC = CandidateList[i];
+      unsigned FirstOccur = *OC.begin();
+
+      // Compute the input sequence if needed.
+      if (OC.InputSeq.empty()) {
+        computeInputOutputSequence(OC);
+
+        // After computing we also compute the input sequences of chains
+        //  that we share size with. We have already calculated the input
+        //  sequence for this chain as it is a subset of our current
+        //  sequence.
+        OutlineCandidate *Cur = &OC;
+        while (Cur->SharedSizeWithNext > 0) {
+          OutlineCandidate *Next = Cur + 1;
+          size_t NewSize = 0;
+          for (size_t e = Cur->InputSeq.size(); NewSize < e; ++NewSize)
+            if (Cur->InputSeq[NewSize].first >= Cur->SharedSizeWithNext)
+              break;
+          Next->InputSeq.assign(Cur->InputSeq.begin(),
+                                Cur->InputSeq.begin() + NewSize);
+          computeInputOutputSequence(*Next, false);
+          Cur = Next;
+        }
+      }
+
+      // Check to see if we share candidates with our predecessor. If we
+      //   do then we can avoid rechecking candidates that we already have
+      //   information for.
+      size_t SharedOccurrencesWithPrev = 1;
+      if (i > StartIdx) {
+        OutlineCandidate &Prev = CandidateList[i - 1];
+        if (Prev.SharedSizeWithNext > 0)
+          SharedOccurrencesWithPrev = Prev.size();
+      }
+
+      // Only recompute the input operands if we didn't share a size with the
+      // previous chain.
+      if (SharedOccurrencesWithPrev == 1) {
+        // Get the operands for the first candidate.
+        InputOperands.clear();
+        UnFoldableInputs.reset();
+        UnFoldableInputs.resize(OC.InputSeq.size());
+        for (size_t i = 0, e = OC.InputSeq.size(); i < e; ++i) {
+          auto &Seq = OC.InputSeq[i];
+          Value *Op =
+              OM.getInstr(FirstOccur + Seq.first)->getOperand(Seq.second);
+          InputOperands.push_back(Op);
+          if (isa<Instruction>(Op) || isa<Argument>(Op))
+            UnFoldableInputs.set(i);
+        }
+      } else {
+        InputOperands.resize(OC.InputSeq.size(), nullptr);
+        UnFoldableInputs.resize(InputOperands.size());
+      }
+
+      // Check to see which inputs won't be folded.
+      for (size_t Ci = SharedOccurrencesWithPrev, Ce = OC.size(); Ci != Ce;
+           ++Ci) {
+        unsigned Occur = OC.getOccurrence(Ci);
+        size_t InputNo = 0;
+        for (auto &Seq : OC.InputSeq) {
+          if (UnFoldableInputs.test(InputNo)) {
+            ++InputNo;
+            continue;
+          }
+          Value *InputOp =
+              OM.getInstr(Occur + Seq.first)->getOperand(Seq.second);
+          if (InputOp != InputOperands[InputNo])
+            UnFoldableInputs.set(InputNo);
+          ++InputNo;
+        }
+      }
+
+      // Remove all of the inputs that will be folded.
+      for (size_t i = 0, e = OC.InputSeq.size(), InputNo = e - 1; i < e;
+           ++i, --InputNo) {
+        if (!UnFoldableInputs.test(InputNo))
+          OC.InputSeq.erase(OC.InputSeq.begin() + InputNo);
+      }
+    }
+    computeOutlineBenefit(CandidateList, StartIdx, EndIdx);
+  }
+
+  // Compute the external input sequence(Inst#+Op#) and outputs of a given
+  // chain.
+  void computeInputOutputSequence(OutlineCandidate &OC,
+                                  bool ComputeInputs = true) {
+    // Inputs are operands that come from outside of the chain range.
+    if (ComputeInputs) {
+      OC.InputSeq.clear();
+      OC.InputSeq.reserve(OC.Len);
+      unsigned FirstOccur = OC.getOccurrence(0);
+      for (size_t InstrIdx = FirstOccur, InstrE = FirstOccur + OC.Len;
+           InstrIdx < InstrE; ++InstrIdx) {
+        OutlinerModule::InstructionInfo &II = OM.getInstrInfo(InstrIdx);
+        for (size_t i = 0, e = II.InputIndexes.size(); i < e; ++i)
+          if (II.InputIndexes[i] < FirstOccur)
+            OC.InputSeq.emplace_back(InstrIdx - FirstOccur, i);
+      }
+    }
+
+    // Outputs are internal instructions that have uses outside of the chain
+    // range.
+    OC.Outputs.clear();
+    for (unsigned Occur : OC) {
+      for (size_t InstrIdx = Occur, InstrE = Occur + OC.Len; InstrIdx < InstrE;
+           ++InstrIdx) {
+        OutlinerModule::InstructionInfo &II = OM.getInstrInfo(InstrIdx);
+        if (II.FarthestInSameBlockOutput >= InstrE)
+          OC.Outputs.set(InstrIdx - Occur);
+      }
+    }
+  }
+
+  // Computes the estimated benefit of a set of potential functions.
+  void computeOutlineBenefit(std::vector<OutlineCandidate> &CandidateList,
+                             size_t StartIdx, size_t EndIdx) {
+    SmallDenseSet<Value *, 8> UniqueInputOperands;
+    SmallPtrSet<Type *, 8> OutputTypes;
+    for (size_t i = StartIdx; i < EndIdx; ++i) {
+      OutlineCandidate &OC = CandidateList[i];
+
+      /// Reset benefit metrics.
+      OC.invalidate();
+
+      // Sanity check.
+      unsigned NumOccurences = OC.size();
+      if (NumOccurences < MinOccurrences)
+        continue;
+
+      // Estimate the cost of this chain of instructions.
+      /// For now we just use the first candidate.
+      unsigned FirstOccur = OC.getOccurrence(0);
+      TargetTransformInfo &TTI = GetTTI(*OM.getInstrFunction(FirstOccur));
+      unsigned ChainCost = 0;
+      for (size_t i = 0, e = OC.Len, InstIdx = FirstOccur; i < e;
+           ++i, ++InstIdx)
+        ChainCost += OM.getInstrCost(TTI, InstIdx);
+
+      /// Estimate inputs to this function.
+      UniqueInputOperands.clear();
+      for (auto &Seq : OC.InputSeq) {
+        Value *IOp =
+            OM.getInstr(FirstOccur + Seq.first)->getOperand(Seq.second);
+        UniqueInputOperands.insert(IOp);
+      }
+
+      unsigned NumFunctionParams = UniqueInputOperands.size();
+      unsigned NumOutputs = OC.Outputs.count();
+      /// We penalize container parameters.
+      for (Value *Op : UniqueInputOperands) {
+        Type *OpTy = Op->getType();
+        if (OpTy->isVectorTy())
+          NumFunctionParams += OpTy->getVectorNumElements();
+        else if (OpTy->isStructTy())
+          NumFunctionParams += OpTy->getStructNumElements();
+      }
+
+      // Compute the output to fold to a return as well as the total number of
+      // outputs passed to the function.
+      if (NumOutputs == 1) {
+        OC.OutputToFold = OC.Outputs.find_first();
+      } else if (NumOutputs > 0) {
+        // Outputs are condensed by type, so the number of actual parameters
+        //  going to the outlined function is the number of distinct types
+        //  for the outputs. We try to reduce this by folding an output that
+        //  is the single member of its type.
+        OutputTypes.clear();
+        SmallDenseMap<Type *, unsigned, 8> BeneficialToFold;
+        for (size_t OutputIdx : OC.Outputs) {
+          Type *ParamEleTy = OM.getInstr(FirstOccur + OutputIdx)->getType();
+          if (OutputTypes.insert(ParamEleTy).second)
+            BeneficialToFold.try_emplace(ParamEleTy, OutputIdx);
+          else
+            BeneficialToFold.erase(ParamEleTy);
+        }
+        NumFunctionParams += OutputTypes.size();
+        if (!BeneficialToFold.empty()) {
+          OC.OutputToFold = 0;
+          for (auto &TyPair : BeneficialToFold)
+            if (OC.OutputToFold < TyPair.second)
+              OC.OutputToFold = TyPair.second;
+          --NumFunctionParams;
+        } else
+          OC.OutputToFold = OC.Outputs.find_last();
+      } else
+        OC.OutputToFold = -1;
+
+      /// The new function contains one instance of the chain of instructions,
+      ///  has to prepare each parameter, and contains a return.
+      unsigned NewFunctionCost =
+          std::min(NumFunctionParams, TTI.getNumberOfRegisters(false)) +
+          ChainCost + 1;
+      unsigned CostFromReLoad = 0;
+
+      /// Add the cost for each output.
+      OutputTypes.clear();
+      for (size_t OutputIdx : OC.Outputs) {
+        Type *ParamEleTy = OM.getInstr(FirstOccur + OutputIdx)->getType();
+        Type *ParamTy = ParamEleTy->getPointerTo();
+
+        // Extremely basic cost estimate for loading and storing a struct type.
+        // FIXME: This needs to be improved.
+        if (ParamEleTy->isStructTy()) {
+          NewFunctionCost += ParamEleTy->getStructNumElements();
+          CostFromReLoad += ParamEleTy->getStructNumElements();
+          continue;
+        }
+        size_t StoreSize = Layout->getTypeStoreSize(ParamTy);
+        size_t AddrSpace = ParamTy->getPointerAddressSpace();
+
+        /// There will be a store into this variable in the outlined function.
+        NewFunctionCost += TTI.getMemoryOpCost(Instruction::Store, ParamEleTy,
+                                               StoreSize, AddrSpace);
+        /// Account for a potential add to the base output pointer.
+        if (!OutputTypes.insert(ParamEleTy).second)
+          NewFunctionCost += 1;
+
+        /// Each output value has a reload in the parent function.
+        /// NOTE: This isn't entirely true if a specific instance doesn't use
+        /// the value.
+        CostFromReLoad += TTI.getMemoryOpCost(Instruction::Load, ParamTy,
+                                              StoreSize, AddrSpace);
+      }
+
+      /// A call is generated at each occurence.
+      ///   = call instruction + prepare each parameter + reload outputs.
+      unsigned CostPerOccurence = 1 + NumFunctionParams + CostFromReLoad;
+
+      // No possibility of benefit.
+      if (CostPerOccurence >= ChainCost)
+        continue;
+
+      // Compute the benefit of the chain and minimum number of candidates
+      // necessary to be profitable.
+      size_t BenefitPerOccurence = ChainCost - CostPerOccurence;
+      OC.MinBeneficialOccurCount = (NewFunctionCost / BenefitPerOccurence);
+      if (NewFunctionCost % BenefitPerOccurence)
+        ++OC.MinBeneficialOccurCount;
+      if (OC.MinBeneficialOccurCount <= NumOccurences) {
+        OC.Benefit = (BenefitPerOccurence * NumOccurences) - NewFunctionCost;
+        if (OC.Benefit < MinBenefit)
+          OC.invalidate();
+      }
+    }
+  }
+
+  // Internal members
+  OutlinerModule &OM;
+  std::vector<OutlineCandidate> &CandidateList;
+  function_ref<TargetTransformInfo &(Function &)> GetTTI;
+  const DataLayout *Layout;
+};
+
+/// \brief An outliner impl for outlining individual instruction chains.
+struct ChainOutlinerImpl {
+  /// \brief Compute the suffix array.
+  //   Basic adapted implementation of SA-IS algorithm.
+  class SuffixArray {
+  public:
+    // Compute the suffix array of /p S with given alphabet size /p AlphabetSize
+    // and store the result in /p SA
+    static void compute(ArrayRef<unsigned> S, std::vector<int> &SA,
+                        unsigned AlphabetSize) {
+      SuffixArray SACtr(S.size(), SA);
+      SACtr.computeSAIS(S, S.size(), AlphabetSize);
+    }
+
+  private:
+    SuffixArray(size_t ArraySize, std::vector<int> &SA) : SA(SA) {
+      SA.resize(ArraySize);
+    }
+
+    template <typename T>
+    void computeSAIS(ArrayRef<T> S, int N, unsigned AlphabetSize) {
+      // Bitvector for LS-type array.
+      BitVector LTypeArray(N);
+
+      // Classify each character from S as either LType or SType.
+      LTypeArray.set(N - 1);
+      for (int i = N - 3, e = 0; i >= e; --i) {
+        // S(i) is type S iff: S(i) < S(i+1) or S(i)==S(i+1) and S(i+1) is type
+        // S
+        if (S[i] < S[i + 1] || (S[i] == S[i + 1] && LTypeArray.test(i + 1)))
+          LTypeArray.set(i);
+      }
+
+      // Stage 1: Reduce the problem and bucket sort all S-substrings.
+      Bucket.resize(AlphabetSize + 1);
+      /// Get the bucket ends.
+      getBuckets(S, true, N, AlphabetSize);
+      for (int i = 0; i < N; ++i)
+        SA[i] = -1;
+      for (int i = 1; i < N; ++i)
+        if (isLMS(i, LTypeArray))
+          SA[--Bucket[S[i]]] = i;
+      induceSA(S, LTypeArray, N, AlphabetSize);
+      Bucket.clear();
+
+      /// Compact the sorted substrings into the first N1 items of the suffix
+      /// array.
+      int N1 = 0;
+      for (int i = 0; i < N; ++i)
+        if (isLMS(SA[i], LTypeArray))
+          SA[N1++] = SA[i];
+
+      /// Find the lexicographic names of the substrings.
+      for (int i = N1; i < N; ++i)
+        SA[i] = -1;
+      int Name = 0, Prev = -1;
+      for (int i = 0; i < N1; ++i) {
+        int Pos = SA[i];
+        for (int d = 0; d < N; ++d) {
+          if (Prev == -1 || S[Pos + d] != S[Prev + d] ||
+              LTypeArray.test(Pos + d) != LTypeArray.test(Prev + d)) {
+            ++Name;
+            Prev = Pos;
+            break;
+          }
+          if (d > 0 &&
+              (isLMS(Pos + d, LTypeArray) || isLMS(Prev + d, LTypeArray)))
+            break;
+        }
+        Pos = (Pos % 2 == 0) ? Pos / 2 : (Pos - 1) / 2;
+        SA[N1 + Pos] = Name - 1;
+      }
+      for (int i = N - 1, j = i; i >= N1; --i)
+        if (SA[i] >= 0)
+          SA[j--] = SA[i];
+
+      // Stage 2: Solve the reduced problem.
+      /// If the names aren't unique enough yet, we recurse until they are.
+      size_t S1Start = N - N1;
+      int *S1 = SA.data() + S1Start;
+      if (Name < N1)
+        computeSAIS(ArrayRef<int>(S1, N1), N1, Name - 1);
+      // Otherwise we can compute the suffix array directly.
+      else {
+        for (int i = 0; i < N1; ++i)
+          SA[S1[i]] = i;
+      }
+
+      // Stage 3: Induce the result from the reduced solution.
+      Bucket.resize(AlphabetSize + 1);
+      /// Place the LMS characters into their respective buckets.
+      getBuckets(S, true, N, AlphabetSize);
+      /// Get P1.
+      for (int i = 1, j = 0; i < N; ++i)
+        if (isLMS(i, LTypeArray))
+          S1[j++] = i;
+      /// Get the index in S.
+      for (int i = 0; i < N1; ++i)
+        SA[i] = S1[SA[i]];
+      /// Initialize the suffix array from N1 to N - 1.
+      for (int i = N1; i < N; ++i)
+        SA[i] = -1;
+      for (int i = N1 - 1; i >= 0; --i) {
+        int j = SA[i];
+        SA[i] = -1;
+        SA[--Bucket[S[j]]] = j;
+      }
+      induceSA(S, LTypeArray, N, AlphabetSize);
+    }
+
+    // Check to see if S(Idx) is a left most S-type character.
+    bool isLMS(int Idx, BitVector &LTypeArray) {
+      return Idx > 0 && LTypeArray.test(Idx) && !LTypeArray.test(Idx - 1);
+    }
+    template <typename T>
+    void getBuckets(ArrayRef<T> S, bool End, unsigned N,
+                    unsigned AlphabetSize) {
+      /// Clear buckets.
+      Bucket.assign(AlphabetSize + 1, 0);
+      /// Compute the size of each bucket.
+      for (size_t i = 0, e = S.size(); i < e; ++i)
+        ++Bucket[S[i]];
+      int Sum = 0;
+      if (!End) {
+        for (size_t i = 0, e = AlphabetSize + 1; i < e; ++i) {
+          Sum += Bucket[i];
+          Bucket[i] = Sum - Bucket[i];
+        }
+      } else
+        for (size_t i = 0; i <= AlphabetSize; ++i)
+          Bucket[i] = Sum += Bucket[i];
+    }
+
+    // Compute SA1
+    template <typename T>
+    void induceSA(ArrayRef<T> S, BitVector &LTypeArray, unsigned N,
+                  unsigned AlphabetSize) {
+      // Induce SA1
+      getBuckets(S, false, N, AlphabetSize);
+      for (size_t i = 0; i < N; ++i) {
+        int j = SA[i] - 1;
+        if (j >= 0 && !LTypeArray.test(j))
+          SA[Bucket[S[j]]++] = j;
+      }
+      // Induce Sas
+      getBuckets(S, true, N, AlphabetSize);
+      for (ssize_t i = N - 1; i >= 0; --i) {
+        int j = SA[i] - 1;
+        if (j >= 0 && LTypeArray.test(j))
+          SA[--Bucket[S[j]]] = j;
+      }
+    }
+    std::vector<int> &SA;
+    std::vector<int> Bucket;
+  };
+
+  // Construct the LCP array for a given suffix array /p SA and string /p S.
+  static std::vector<int> computeLCP(ArrayRef<unsigned> S, ArrayRef<int> SA) {
+    int N = S.size();
+    std::vector<int> LCP(N), Rank(N);
+    for (int i = 0; i < N; ++i)
+      Rank[SA[i]] = i;
+    for (int i = 0, k = 0; i < N; ++i) {
+      if (Rank[i] == N - 1) {
+        k = 0;
+        continue;
+      }
+      int j = SA[Rank[i] + 1];
+      while (i + k < N && j + k < N && S[i + k] == S[j + k])
+        ++k;
+      LCP[Rank[i]] = k;
+      if (k > 0)
+        --k;
+    }
+    return LCP;
+  }
+
+  // Check to see if an instruction chain starting at /p I with size /p Len is
+  // potentially beneficial to outline.
+  static bool isPotentiallyBeneficial(Instruction *I, size_t Len) {
+    SmallPtrSet<Value *, 8> Chain;
+    BasicBlock::iterator It = I->getIterator();
+    for (size_t i = 0; i < Len; ++i, ++It) {
+      if (CallInst *CI = dyn_cast<CallInst>(&*It)) {
+        int Cost = isa<Function>(CI->getCalledValue()) ? 0 : 1;
+        for (Value *Op : CI->arg_operands())
+          if (isa<Instruction>(Op) && !Chain.count(Op))
+            ++Cost;
+        int NumConstOperands = CI->getNumArgOperands() - Cost;
+        if (NumConstOperands > Cost)
+          return true;
+      }
+      Chain.insert(&*It);
+    }
+    return false;
+  }
+
+  // Find all of the possibly profitable outline chains.
+  static void
+  findOutliningOccurrences(std::vector<OutlineCandidate> &CandidateList,
+                           OutlinerModule &OM) {
+    CandidateList.clear();
+
+    // Build the suffix array and longest common prefix array.
+    ArrayRef<unsigned> CongruencyVec = OM.getCongruencyVector();
+    std::vector<int> SuffixArr, LcpArr;
+    SuffixArray::compute(CongruencyVec, SuffixArr,
+                         OM.getNumCongruencyClasses());
+    LcpArr = computeLCP(CongruencyVec, SuffixArr);
+
+    // An interval tree of our current candidates.
+    BitVector Occurrences(CongruencyVec.size());
+
+    /// The size of the chain must be more than our constraint minimum.
+    auto ShouldConsider = [&](size_t Size) {
+      return Size >= MinInstructionLength;
+    };
+
+    // Try to guess the amount of candidates we could have for this module.
+    //  * Tuned via clang build *
+    size_t NumPotentialOccurrences = 0, CurrentSizeSeq = 1;
+    std::for_each(LcpArr.begin(), LcpArr.end(), [&](int Size) {
+      if (ShouldConsider(Size))
+        NumPotentialOccurrences += ++CurrentSizeSeq;
+      else
+        CurrentSizeSeq = 1;
+    });
+    CandidateList.reserve(NumPotentialOccurrences * 0.025);
+
+    // Walk the suffix array to build potential candidates.
+    SmallDenseSet<size_t, 16> FailedOccurrences;
+    size_t PrevSize = 0;
+    std::vector<unsigned> ChainOccurrences;
+    for (size_t i = 1, e = SuffixArr.size(); i < e; ++i) {
+      size_t Size = LcpArr[i];
+
+      // Preskip invalid size.
+      if (!ShouldConsider(Size)) {
+        PrevSize = 0;
+        continue;
+      }
+
+      size_t OccurIdx = SuffixArr[i];
+      Instruction *OccurInst = OM.getInstr(OccurIdx);
+      assert(OccurInst && "Matching with invalid instruction.");
+
+      // Here we pre-prune candidates of small sizes that are most likely not
+      // going to be profitable anyway.
+      if (Size < EarlyPruningSize &&
+          !isPotentiallyBeneficial(OccurInst, Size)) {
+        PrevSize = 0;
+        continue;
+      }
+
+      // We have already matched against this size.
+      if (PrevSize >= Size) {
+        PrevSize = Size;
+        continue;
+      }
+
+      // Create a new interval tree with our current candidate to pre prune
+      //   overlaps.
+      ChainOccurrences.clear();
+      Occurrences.set(OccurIdx, OccurIdx + Size);
+      ChainOccurrences.push_back(OccurIdx);
+      FailedOccurrences.clear();
+      bool HasPreviousSharedOccurrence = false;
+
+      // Continuously consider potentital chain sizes for this candidate until
+      // they are no longer profitable.
+      size_t OrigSize = Size, LastValidSize = 0;
+      for (size_t SizeFromIdx = i, AugmentAmount = 0; ShouldConsider(Size);) {
+        bool AddedNewOccurrence = false;
+
+        // Recheck the prune size each iteration.
+        if (Size < EarlyPruningSize &&
+            !isPotentiallyBeneficial(OccurInst, Size))
+          break;
+
+        // Augment the candidate set by the change in size from the
+        // last iteration.
+        if (AugmentAmount > 0)
+          for (size_t Idx : ChainOccurrences)
+            Occurrences.reset(Idx + Size, Idx + Size + AugmentAmount);
+        LastValidSize = Size;
+
+        // After augmenting the candidate set, there may be new candidates that
+        // no longer overlap with any of the others currently being considered.
+        for (auto It = FailedOccurrences.begin(), E = FailedOccurrences.end();
+             It != E;) {
+          size_t Idx = *It;
+          ++It;
+          if (Occurrences.find_first_in(Idx, Idx + Size) != -1)
+            continue;
+          FailedOccurrences.erase(Idx);
+          Occurrences.set(Idx, Idx + Size);
+          ChainOccurrences.push_back(Idx);
+          AddedNewOccurrence = true;
+        }
+
+        // Count the number of occurrences.
+        for (size_t j = i + ChainOccurrences.size(); j < e; ++j) {
+          // The longest common prefix must be able to hold our size.
+          if ((size_t)LcpArr[j - 1] < Size)
+            break;
+
+          // Check to see if this candidate overlaps with any of our currently
+          // considered candidates. If it doesn't we add it to our current set.
+          size_t JIdx = SuffixArr[j];
+          if (Occurrences.find_first_in(JIdx, JIdx + Size) == -1) {
+            Occurrences.set(JIdx, JIdx + Size);
+            ChainOccurrences.push_back(JIdx);
+            AddedNewOccurrence = true;
+          } else
+            FailedOccurrences.insert(JIdx);
+
+          // If our next size is less than the current, we won't get any more
+          //  candidates for this chain.
+          if ((size_t)LcpArr[j] < Size)
+            break;
+        }
+
+        // If we added a new candidate and we have enough to satisfy our
+        // constraints then we build a new outline chain candidate.
+        if (AddedNewOccurrence &&
+            ChainOccurrences.size() >= MinOccurrences) {
+          /// Cache shared sizes between candidates chains to make analysis
+          /// easier.
+          if (HasPreviousSharedOccurrence)
+            CandidateList.back().SharedSizeWithNext = Size;
+          else
+            HasPreviousSharedOccurrence = true;
+          /// Build new function with candidate sequence.
+          CandidateList.emplace_back(Size);
+
+          /// Add each candidate.
+          OutlineCandidate &OC = CandidateList.back();
+          OC.Occurrences = ChainOccurrences;
+        }
+
+        // Find the next size to consider for this candidate.
+        for (size_t NewSizeE = e - 1; ++SizeFromIdx < NewSizeE;) {
+          size_t NewSize = static_cast<size_t>(LcpArr[SizeFromIdx]);
+          if (NewSize < Size) {
+            AugmentAmount = Size - NewSize;
+            Size = NewSize;
+            break;
+          }
+        }
+
+        // If we have already encountered a greater size, then the new size
+        //  was either invalid or we've already considered this size but
+        //  with more candidates.
+        if (Size == LastValidSize || Size <= PrevSize)
+          break;
+      }
+      for (unsigned Idx : ChainOccurrences)
+        Occurrences.reset(Idx, Idx + LastValidSize);
+      PrevSize = OrigSize;
+    }
+  }
+};
+
+/// \brief Common outliner interface.
+class CodeSizeOutlinerImpl {
+public:
+  CodeSizeOutlinerImpl(function_ref<TargetTransformInfo &(Function &)> GetTTI)
+      : GetTTI(GetTTI) {}
+
+  // Run the outliner over the provided module /p M.
+  bool run(Module &M, unsigned SizeLevel, ProfileSummaryInfo *PSI,
+           function_ref<BlockFrequencyInfo &(Function &)> GetBFI) {
+    if (!EnableOutliner)
+      return false;
+
+    // At -Os we only run if we have profile data.
+    bool FavorFastCode = SizeLevel == 1;
+    bool HasProfileData = PSI->hasProfileSummary();
+    if (!HasProfileData && FavorFastCode)
+      return false;
+
+    EmitRemarks = areRemarksEnabled(M);
+    OutlinerModule OM;
+    OM.mapModule(M, FavorFastCode, PSI, GetBFI);
+
+    // No potential candidates.
+    if (OM.getNumMappedInstructions() <
+        MinOccurrences * MinInstructionLength)
+      return false;
+
+    // Find all possibly profitable candidates to outline.
+    std::vector<OutlineCandidate> CandidateList;
+    ChainOutlinerImpl::findOutliningOccurrences(CandidateList, OM);
+    CandidateList.reserve(CandidateList.size() * 1.5);
+    if (CandidateList.empty())
+      return false;
+
+    // Analyze and verify the candidates that were found.
+    OutlinerAnalysisImpl OAI(OM, CandidateList, GetTTI, &M.getDataLayout());
+    OAI.analyzeCandidateList();
+    return pruneAndOutlineCandidates(CandidateList, OM, HasProfileData);
+  }
+
+private:
+  // Prune overlapping candidates based upon the estimated benefit found
+  //  during analysis.
+  bool pruneAndOutlineCandidates(std::vector<OutlineCandidate> &CandidateList,
+                                 OutlinerModule &OM, bool EmitProfileData) {
+    FunctionSplicer FS(EmitProfileData);
+    BitVector InsertedOccurrences(OM.getNumMappedInstructions());
+    std::vector<unsigned> CandidatesByBenefit;
+    CandidatesByBenefit.reserve(CandidateList.size());
+
+    // Sort candidates based upon estimated benefit.
+    for (unsigned i = 0, e = CandidateList.size(); i < e; ++i)
+      if (CandidateList[i].isValid())
+        CandidatesByBenefit.push_back(i);
+    std::sort(CandidatesByBenefit.begin(), CandidatesByBenefit.end(),
+              [&](unsigned L, unsigned R) {
+                return CandidateList[L].Benefit > CandidateList[R].Benefit;
+              });
+    BitVector ValidOccurrencesPerCandidate;
+    unsigned OutlinedCandidates = 0;
+    for (unsigned CandIdx : CandidatesByBenefit) {
+      OutlineCandidate &OC = CandidateList[CandIdx];
+      ValidOccurrencesPerCandidate.reset();
+      ValidOccurrencesPerCandidate.resize(OC.size());
+
+      // Check overlaps.
+      unsigned NumValidOccur = OC.size();
+      for (unsigned i = 0, e = OC.size(); i < e; ++i) {
+        unsigned Occur = OC.getOccurrence(i);
+        if (InsertedOccurrences.find_first_in(Occur, Occur + OC.Len) == -1)
+          ValidOccurrencesPerCandidate.set(i);
+        else if (--NumValidOccur < OC.MinBeneficialOccurCount)
+          break;
+      }
+
+      // Add valid occurrences if this candidate is still profitable.
+      if (NumValidOccur < OC.MinBeneficialOccurCount)
+        continue;
+
+      auto ValidOccurI = ValidOccurrencesPerCandidate.set_bits_begin();
+      FS.prepareForNewInstance(OC, OM, *ValidOccurI);
+      for (unsigned ValidOccurIdx = 0; ValidOccurIdx != NumValidOccur;
+           ++ValidOccurI) {
+        unsigned Occur = OC.getOccurrence(*ValidOccurI);
+        InsertedOccurrences.set(Occur, Occur + OC.Len);
+        emitOptRemark(OM, OC, OutlinedCandidates, ValidOccurIdx++, Occur);
+        FS.outlineOccurrence(OC, Occur, OM);
+      }
+      ++OutlinedCandidates;
+      FS.finalize(OC);
+
+#ifndef NDEBUG
+      Function *OF = OM.getInstrFunction(
+          OC.getOccurrence(ValidOccurrencesPerCandidate.find_first()));
+      DEBUG(dbgs() << "** Outlining : " << OF->getName() << "\n"
+                   << " occurrences : " << NumValidOccur << "\n"
+                   << " size : " << OC.Len << "\n"
+                   << " benefit : " << OC.Benefit << "\n");
+#endif
+    }
+    NumCandidatesOutlined += OutlinedCandidates;
+    return OutlinedCandidates > 0;
+  }
+
+  // \brief Emit a remark about a code block that was outlined.
+  void emitOptRemark(OutlinerModule &OM, OutlineCandidate &OC,
+                     unsigned CandidateIdx, unsigned ValidOccurNum,
+                     unsigned Occur) {
+    if (!EmitRemarks)
+      return;
+    Instruction *Head = OM.getInstr(Occur);
+    Instruction *Tail = OM.getInstr(Occur + OC.Len - 1);
+    Function *ParentFn = Head->getFunction();
+    OptimizationRemarkEmitter ORE(ParentFn);
+
+    std::ostringstream NameStream, AdditionalInfo;
+    NameStream << "Outlining Candidate " << CandidateIdx << ": Occurrence "
+               << ValidOccurNum;
+    AdditionalInfo << ": " << OC.Len << " IR instructions. : " << OC.Benefit
+                   << " estimated benefit.";
+
+    std::string Msg = NameStream.str();
+    std::string Additional = AdditionalInfo.str();
+    if (Tail->getDebugLoc() != Head->getDebugLoc()) {
+      ORE.emit(OptimizationRemark(DEBUG_TYPE, "Outlined", Head)
+               << Msg << Additional << " - Begin");
+      ORE.emit(OptimizationRemark(DEBUG_TYPE, "Outlined", Tail)
+               << Msg << " - End");
+    } else
+      ORE.emit(OptimizationRemark(DEBUG_TYPE, "Outlined", Head)
+               << Msg << Additional);
+  }
+
+  // Emitting optimization remarks creates a compile hit due to the string
+  //   manipulation. Check if its enabled so that we can avoid it.
+  bool areRemarksEnabled(Module &M) {
+    bool IsEnabled = OptimizationRemark::isEnabled(DEBUG_TYPE);
+    if (!IsEnabled && !M.empty()) {
+      OptimizationRemarkEmitter ORE(&M.getFunctionList().front());
+      IsEnabled = ORE.allowExtraAnalysis();
+    }
+    return IsEnabled;
+  }
+
+  // private members.
+  function_ref<TargetTransformInfo &(Function &)> GetTTI;
+  bool EmitRemarks;
+};
+} // namespace
+
+PreservedAnalyses CodeSizeOutlinerPass::run(Module &M,
+                                            ModuleAnalysisManager &AM) {
+  auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
+  std::function<TargetTransformInfo &(Function &)> GetTTI =
+      [&](Function &F) -> TargetTransformInfo & {
+    return FAM.getResult<TargetIRAnalysis>(F);
+  };
+  std::function<BlockFrequencyInfo &(Function &)> GetBFI =
+      [&](Function &F) -> BlockFrequencyInfo & {
+    return FAM.getResult<BlockFrequencyAnalysis>(F);
+  };
+  ProfileSummaryInfo *PSI = &AM.getResult<ProfileSummaryAnalysis>(M);
+  CodeSizeOutlinerImpl Impl(GetTTI);
+  return Impl.run(M, SizeLevel, PSI, GetBFI) ? PreservedAnalyses::none()
+                                             : PreservedAnalyses::all();
+}
+
+struct CodeSizeOutlinerLegacyPass : public ModulePass {
+  static char ID; // Pass identification, replacement for typeid
+  CodeSizeOutlinerLegacyPass(unsigned SizeLevel = 2)
+      : ModulePass(ID), SizeLevel(SizeLevel) {
+    initializeCodeSizeOutlinerLegacyPassPass(*PassRegistry::getPassRegistry());
+  }
+  void getAnalysisUsage(AnalysisUsage &AU) const override {
+    AU.addRequired<ProfileSummaryInfoWrapperPass>();
+    AU.addRequired<TargetTransformInfoWrapperPass>();
+  }
+  bool runOnModule(Module &M) override {
+    if (skipModule(M))
+      return false;
+    TargetTransformInfoWrapperPass *TTIWP =
+        &getAnalysis<TargetTransformInfoWrapperPass>();
+    DenseMap<Function *, TargetTransformInfo> TTIMap;
+    std::function<TargetTransformInfo &(Function &)> GetTTI =
+        [&](Function &F) -> TargetTransformInfo & {
+      auto TTIIt = TTIMap.find(&F);
+      if (TTIIt == TTIMap.end())
+        TTIIt = TTIMap.try_emplace(&F, std::move(TTIWP->getTTI(F))).first;
+      return TTIIt->second;
+    };
+    std::unique_ptr<BlockFrequencyInfo> CurBFI;
+    std::function<BlockFrequencyInfo &(Function &)> GetBFI =
+        [&](Function &F) -> BlockFrequencyInfo & {
+      DominatorTree DT(F);
+      LoopInfo LI(DT);
+      BranchProbabilityInfo BPI(F, LI);
+      CurBFI.reset(new BlockFrequencyInfo(F, BPI, LI));
+      return *CurBFI.get();
+    };
+    ProfileSummaryInfo *PSI =
+        getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();
+    CodeSizeOutlinerImpl Impl(GetTTI);
+    return Impl.run(M, SizeLevel, PSI, GetBFI);
+  }
+  unsigned SizeLevel;
+};
+char CodeSizeOutlinerLegacyPass::ID = 0;
+INITIALIZE_PASS_BEGIN(CodeSizeOutlinerLegacyPass, DEBUG_TYPE,
+                      "Code Size Outliner", false, false)
+INITIALIZE_PASS_DEPENDENCY(ProfileSummaryInfoWrapperPass)
+INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)
+INITIALIZE_PASS_END(CodeSizeOutlinerLegacyPass, DEBUG_TYPE,
+                    "Code Size Outliner", false, false)
+ModulePass *llvm::createCodeSizeOutlinerPass(unsigned SizeLevel) {
+  return new CodeSizeOutlinerLegacyPass(SizeLevel);
+}
diff --git a/lib/Transforms/IPO/IPO.cpp b/lib/Transforms/IPO/IPO.cpp
index 89518f3c5fa..462c168ce0c 100644
--- a/lib/Transforms/IPO/IPO.cpp
+++ b/lib/Transforms/IPO/IPO.cpp
@@ -25,6 +25,7 @@ using namespace llvm;
 
 void llvm::initializeIPO(PassRegistry &Registry) {
   initializeArgPromotionPass(Registry);
+  initializeCodeSizeOutlinerLegacyPassPass(Registry);
   initializeConstantMergeLegacyPassPass(Registry);
   initializeCrossDSOCFIPass(Registry);
   initializeDAEPass(Registry);
diff --git a/lib/Transforms/IPO/PassManagerBuilder.cpp b/lib/Transforms/IPO/PassManagerBuilder.cpp
index 941efb210d1..e1ff432f239 100644
--- a/lib/Transforms/IPO/PassManagerBuilder.cpp
+++ b/lib/Transforms/IPO/PassManagerBuilder.cpp
@@ -149,6 +149,9 @@ static cl::opt<bool>
                               cl::Hidden,
                               cl::desc("Disable shrink-wrap library calls"));
 
+static cl::opt<bool> EnableEarlyCSO(
+  "enable-early-cso", cl::init(false), cl::Hidden,
+  cl::desc("Enable an early run of the code size outliner pass (default = off)"));
 PassManagerBuilder::PassManagerBuilder() {
     OptLevel = 2;
     SizeLevel = 0;
@@ -464,6 +467,10 @@ void PassManagerBuilder::populateModulePassManager(
     MPM.add(createPGOIndirectCallPromotionLegacyPass());
   }
 
+  // Add an early run of the code size outliner pass.
+  if (EnableEarlyCSO && SizeLevel > 0)
+    MPM.add(createCodeSizeOutlinerPass(SizeLevel));
+
   if (EnableNonLTOGlobalsModRef)
     // We add a module alias analysis pass here. In part due to bugs in the
     // analysis infrastructure this "works" in that the analysis stays alive
@@ -650,6 +657,10 @@ void PassManagerBuilder::populateModulePassManager(
       MPM.add(createGlobalDCEPass());         // Remove dead fns and globals.
       MPM.add(createConstantMergePass());     // Merge dup global constants
     }
+
+    // Add a late run of the code size outliner pass.
+    if(SizeLevel > 0)
+      MPM.add(createCodeSizeOutlinerPass(SizeLevel));
   }
 
   if (MergeFunctions)
diff --git a/test/Transforms/CodeSizeOutliner/attributes.ll b/test/Transforms/CodeSizeOutliner/attributes.ll
new file mode 100644
index 00000000000..fc48316f27f
--- /dev/null
+++ b/test/Transforms/CodeSizeOutliner/attributes.ll
@@ -0,0 +1,46 @@
+; RUN: opt < %s -codesizeoutliner -enable-cso -cso-min-benefit=0 -simplifycfg -S | FileCheck %s
+; Check to make sure that the outliner doesnt outline incompatible functions.
+
+define void @target_cpu_1() #0 {
+; CHECK-LABEL: @target_cpu_1
+  %1 = call i32 @someFn(i32 0, i32 1, i32 2)
+; CHECK: call void @cso(i32 2)
+
+  %2 = call i32 @someFn(i32 0, i32 1, i32 4)
+; CHECK-NEXT: call void @cso(i32 4)
+
+  %3 = call i32 @someFn(i32 0, i32 1, i32 6)
+; CHECK-NEXT: call void @cso(i32 6)
+  ret void
+}
+
+
+define void @target_cpu_2() #1 {
+; CHECK-LABEL: @target_cpu_2
+  %1 = call i32 @someFn(i32 0, i32 1, i32 2)
+; CHECK: call void @cso.1
+  ret void
+}
+
+define void @target_cpu_3() #1 {
+; CHECK-LABEL: @target_cpu_3
+  %1 = call i32 @someFn(i32 0, i32 1, i32 2)
+; CHECK: call void @cso.1
+
+  %2 = call i32 @someFn(i32 0, i32 1, i32 4)
+; CHECK: call void @cso.1
+  ret void
+}
+
+
+; CHECK:define {{.*}} void @cso(i32) {{.*}} #0
+; CHECK: call i32 @someFn(i32 0, i32 1, i32 %0)
+
+; CHECK:define {{.*}} void @cso.1{{.*}} #1
+; CHECK: call i32 @someFn(i32 0, i32 1, i32 %0)
+
+
+declare i32 @someFn(i32, i32, i32)
+
+attributes #0 = { "target-cpu"="x86-64" }
+attributes #1 = { "target-cpu"="corei7" }
\ No newline at end of file
diff --git a/test/Transforms/CodeSizeOutliner/basic.ll b/test/Transforms/CodeSizeOutliner/basic.ll
new file mode 100644
index 00000000000..556015c9f91
--- /dev/null
+++ b/test/Transforms/CodeSizeOutliner/basic.ll
@@ -0,0 +1,22 @@
+; RUN: opt < %s -codesizeoutliner -enable-cso -cso-min-benefit=0 -simplifycfg -S | FileCheck %s
+
+define void @foo() {
+; CHECK-LABEL: @foo
+  %1 = call i32 @someFn(i32 0, i32 1, i32 2)
+; CHECK: call void @cso(i32 2)
+
+  %2 = call i32 @someFn(i32 0, i32 1, i32 4)
+; CHECK-NEXT: call void @cso(i32 4)
+
+  %3 = call i32 @someFn(i32 0, i32 1, i32 6)
+; CHECK-NEXT: call void @cso(i32 6)
+  ret void
+}
+
+
+
+; CHECK:define {{.*}} void @cso
+; CHECK: call i32 @someFn(i32 0, i32 1, i32 %0)
+
+
+declare i32 @someFn(i32, i32, i32)
diff --git a/test/Transforms/CodeSizeOutliner/multioutput.ll b/test/Transforms/CodeSizeOutliner/multioutput.ll
new file mode 100644
index 00000000000..27334596315
--- /dev/null
+++ b/test/Transforms/CodeSizeOutliner/multioutput.ll
@@ -0,0 +1,41 @@
+; RUN: opt < %s -codesizeoutliner -enable-cso -cso-min-benefit=1 -simplifycfg -S | FileCheck %s
+
+define i32 @foo() {
+entry:
+; CHECK-LABEL: @foo
+; CHECK: alloca i32
+  %0 = call i32 @someFn(i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 2)
+  %1 = add i32 1, %0
+  %2 = udiv i32 1, %0
+  
+  %3 = call i32 @someFn(i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 2)
+  %4 = add i32 1, %3
+  %5 = mul i32 1, %0
+
+  %6 = call i32 @someFn(i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 2)
+  %7 = add i32 1, %6
+  %8 = sub i32 1, %0
+
+  %9 = call i32 @someFn(i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 4)
+  %10 = add i32 1, %9
+
+
+  ; CHECK: %12 = call i32 @cso(i32 6, i32* %0)
+  ; CHECK-NEXT: %13 = load i32, i32* %0
+  ; CHECK-NEXT: %14 = add i32 %13, %12
+  ; CHECK-NEXT: ret i32 %14 
+  %11 = call i32 @someFn(i32 0, i32 0, i32 0, i32 0, i32 0, i32 1, i32 6)
+  %12 = add i32 1, %11
+  %13 = add i32 %11, %12
+  ret i32 %13
+}
+
+
+; CHECK:define {{.*}} i32 @cso(i32, i32*)
+; CHECK: %3 = call {{.*}}i32 %0)
+; CHECK-NEXT: store i32 %3, i32* %1
+; CHECK-NEXT: %4 = add
+; CHECK: ret i32 %4
+
+
+declare i32 @someFn(i32, i32, i32, i32, i32, i32, i32)
diff --git a/test/Transforms/CodeSizeOutliner/output.ll b/test/Transforms/CodeSizeOutliner/output.ll
new file mode 100644
index 00000000000..35577b1e6ee
--- /dev/null
+++ b/test/Transforms/CodeSizeOutliner/output.ll
@@ -0,0 +1,27 @@
+; RUN: opt < %s -codesizeoutliner -enable-cso -cso-min-benefit=0 -simplifycfg -S | FileCheck %s
+
+define i32 @foo() {
+entry:
+; CHECK-LABEL: @foo
+  %0 = call i32 @someFn(i32 0, i32 0, i32 1, i32 2)
+  %1 = call i32 @someFn(i32 0, i32 0, i32 1, i32 2)
+  %2 = call i32 @someFn(i32 0, i32 0, i32 1, i32 2)
+  %3 = call i32 @someFn(i32 0, i32 0, i32 1, i32 4)
+  %4 = call i32 @someFn(i32 0, i32 0, i32 1, i32 6)
+
+  ; CHECK: %0 = call i32 @cso(i32 2)
+  ; CHECK-NEXT: %1 = call i32 @cso(i32 2)
+  ; CHECK-NEXT: %2 = call i32 @cso(i32 2)
+  ; CHECK-NEXT: %3 = call i32 @cso(i32 4)
+  ; CHECK-NEXT: %4 = call i32 @cso(i32 6)
+  ; CHECK-NEXT: ret i32 %4
+  ret i32 %4
+}
+
+
+; CHECK:define {{.*}} i32 @cso
+; CHECK: call {{.*}}i32 %0)
+; CHECK: ret i32 %2
+
+
+declare i32 @someFn(i32, i32, i32, i32)
-- 
2.13.3

